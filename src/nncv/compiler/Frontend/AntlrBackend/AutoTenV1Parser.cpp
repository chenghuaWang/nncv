
// Generated from ../AutoTenV1Parser.g4 by ANTLR 4.13.0

#include "nncv/compiler/Frontend/AntlrBackend/AutoTenV1ParserListener.h"
#include "nncv/compiler/Frontend/AntlrBackend/AutoTenV1ParserVisitor.h"

#include "nncv/compiler/Frontend/AntlrBackend/AutoTenV1Parser.h"

using namespace antlrcpp;
using namespace antlrcpp;

using namespace antlr4;

namespace {

struct AutoTenV1ParserStaticData final {
  AutoTenV1ParserStaticData(std::vector<std::string> ruleNames,
                            std::vector<std::string> literalNames,
                            std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)),
        literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  AutoTenV1ParserStaticData(const AutoTenV1ParserStaticData&) = delete;
  AutoTenV1ParserStaticData(AutoTenV1ParserStaticData&&) = delete;
  AutoTenV1ParserStaticData& operator=(const AutoTenV1ParserStaticData&) = delete;
  AutoTenV1ParserStaticData& operator=(AutoTenV1ParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag autotenv1parserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
    AutoTenV1ParserStaticData* autotenv1parserParserStaticData = nullptr;

void autotenv1parserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (autotenv1parserParserStaticData != nullptr) { return; }
#else
  assert(autotenv1parserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<AutoTenV1ParserStaticData>(
      std::vector<std::string>{"sourceFile",
                               "packageClause",
                               "compileFlags",
                               "declaration",
                               "typeDecl",
                               "typeSpec",
                               "type_",
                               "typeName",
                               "typeLit",
                               "arrayType",
                               "arrayLength",
                               "elementType",
                               "pointerType",
                               "implType",
                               "sliceType",
                               "mapType",
                               "methodSpec",
                               "functionType",
                               "varDecl",
                               "varSpec",
                               "signature",
                               "result",
                               "parameters",
                               "index",
                               "slice_",
                               "typeAssertion",
                               "arguments",
                               "methodExpr",
                               "parameterDecl",
                               "expression",
                               "primaryExpr",
                               "conversion",
                               "nonNamedType",
                               "operand",
                               "expressionList",
                               "identifierList",
                               "literal",
                               "basicLit",
                               "operandName",
                               "qualifiedIdent",
                               "compositeLit",
                               "literalType",
                               "literalValue",
                               "elementList",
                               "keyedElement",
                               "key",
                               "element",
                               "structType",
                               "fieldDecl",
                               "embeddedField",
                               "functionLit",
                               "functionDecl",
                               "block",
                               "statementList",
                               "statement",
                               "simpleStmt",
                               "expressionStmt",
                               "incDecStmt",
                               "assignment",
                               "assign_op",
                               "shortVarDecl",
                               "emptyStmt",
                               "labeledStmt",
                               "returnStmt",
                               "breakStmt",
                               "continueStmt",
                               "gotoStmt",
                               "fallthroughStmt",
                               "ifStmt",
                               "switchStmt",
                               "exprSwitchStmt",
                               "exprCaseClause",
                               "exprSwitchCase",
                               "typeSwitchStmt",
                               "typeSwitchGuard",
                               "typeCaseClause",
                               "typeSwitchCase",
                               "typeList",
                               "forStmt",
                               "forClause",
                               "whileStmt",
                               "doWhileStmt",
                               "eos"},
      std::vector<std::string>{"",           "",          "",
                               "",           "",          "",
                               "",           "",          "'int8'",
                               "'int16'",    "'int32'",   "'int64'",
                               "'float32'",  "'float64'", "'char'",
                               "'bool'",     "'string'",  "'Tensor'",
                               "'var'",      "'false'",   "'true'",
                               "'void'",     "'nil'",     "'break'",
                               "'continue'", "'goto'",    "'fallthrough'",
                               "'if'",       "'while'",   "'for'",
                               "'else'",     "'do'",      "'switch'",
                               "'case'",     "'default'", "'func'",
                               "'return'",   "'struct'",  "'type'",
                               "'package'",  "'impl'",    "'pub'",
                               "'sizeof'",   "'('",       "')'",
                               "'['",        "']'",       "'{'",
                               "'}'",        "'+'",       "'-'",
                               "'*'",        "'/'",       "",
                               "",           "'&'",       "'|'",
                               "'~'",        "",          "'='",
                               "':='",       "'<'",       "'>'",
                               "'<<'",       "'>>'",      "'!='",
                               "'=='",       "'<='",      "'>='",
                               "",           "",          "'++'",
                               "'--'",       "','",       "'->'",
                               "':'",        "'.'",       "'.*'",
                               "'->*'",      "'@'",       "';'",
                               "'map'",      "'...'"},
      std::vector<std::string>{"",
                               "IntegerLiteral",
                               "CharacterLiteral",
                               "FloatingLiteral",
                               "StringLiteral",
                               "BooleanLiteral",
                               "PointerLiteral",
                               "UserDefinedLiteral",
                               "Int8",
                               "Int16",
                               "Int32",
                               "Int64",
                               "Float32",
                               "Float64",
                               "Char",
                               "Bool",
                               "String",
                               "Tensor",
                               "Var",
                               "False_",
                               "True_",
                               "Void",
                               "Nilptr",
                               "Break",
                               "Continue",
                               "Goto",
                               "Fallthrough",
                               "If",
                               "While",
                               "For",
                               "Else",
                               "Do",
                               "Switch",
                               "Case",
                               "Default",
                               "Function",
                               "Return",
                               "Struct",
                               "Type",
                               "Package",
                               "Impl",
                               "Public",
                               "Sizeof",
                               "LeftParen",
                               "RightParen",
                               "LeftBracket",
                               "RightBracket",
                               "LeftBrace",
                               "RightBrace",
                               "Plus",
                               "Minus",
                               "Star",
                               "Div",
                               "Mod",
                               "Caret",
                               "And",
                               "Or",
                               "Tilde",
                               "Not",
                               "Assign",
                               "DeclareAssign",
                               "Less",
                               "Greater",
                               "LeftShift",
                               "RightShift",
                               "NotEqual",
                               "Equal",
                               "LessEqual",
                               "GreaterEqual",
                               "AndAnd",
                               "OrOr",
                               "PlusPlus",
                               "MinusMinus",
                               "Comma",
                               "ArrowReturnType",
                               "Colon",
                               "Dot",
                               "DotStar",
                               "ArrowStar",
                               "At",
                               "Semi",
                               "Map",
                               "Ellipsis",
                               "Identifier",
                               "DecimalLiteral",
                               "OctalLiteral",
                               "HexadecimalLiteral",
                               "BinaryLiteral",
                               "Integersuffix",
                               "UserDefinedIntegerLiteral",
                               "UserDefinedFloatingLiteral",
                               "UserDefinedStringLiteral",
                               "UserDefinedCharacterLiteral",
                               "Whitespace",
                               "Newline",
                               "BlockComment",
                               "LineComment"});
  static const int32_t serializedATNSegment[] = {
      4,   1,   96,  824, 2,   0,   7,   0,   2,   1,   7,   1,   2,   2,   7,   2,   2,   3,   7,
      3,   2,   4,   7,   4,   2,   5,   7,   5,   2,   6,   7,   6,   2,   7,   7,   7,   2,   8,
      7,   8,   2,   9,   7,   9,   2,   10,  7,   10,  2,   11,  7,   11,  2,   12,  7,   12,  2,
      13,  7,   13,  2,   14,  7,   14,  2,   15,  7,   15,  2,   16,  7,   16,  2,   17,  7,   17,
      2,   18,  7,   18,  2,   19,  7,   19,  2,   20,  7,   20,  2,   21,  7,   21,  2,   22,  7,
      22,  2,   23,  7,   23,  2,   24,  7,   24,  2,   25,  7,   25,  2,   26,  7,   26,  2,   27,
      7,   27,  2,   28,  7,   28,  2,   29,  7,   29,  2,   30,  7,   30,  2,   31,  7,   31,  2,
      32,  7,   32,  2,   33,  7,   33,  2,   34,  7,   34,  2,   35,  7,   35,  2,   36,  7,   36,
      2,   37,  7,   37,  2,   38,  7,   38,  2,   39,  7,   39,  2,   40,  7,   40,  2,   41,  7,
      41,  2,   42,  7,   42,  2,   43,  7,   43,  2,   44,  7,   44,  2,   45,  7,   45,  2,   46,
      7,   46,  2,   47,  7,   47,  2,   48,  7,   48,  2,   49,  7,   49,  2,   50,  7,   50,  2,
      51,  7,   51,  2,   52,  7,   52,  2,   53,  7,   53,  2,   54,  7,   54,  2,   55,  7,   55,
      2,   56,  7,   56,  2,   57,  7,   57,  2,   58,  7,   58,  2,   59,  7,   59,  2,   60,  7,
      60,  2,   61,  7,   61,  2,   62,  7,   62,  2,   63,  7,   63,  2,   64,  7,   64,  2,   65,
      7,   65,  2,   66,  7,   66,  2,   67,  7,   67,  2,   68,  7,   68,  2,   69,  7,   69,  2,
      70,  7,   70,  2,   71,  7,   71,  2,   72,  7,   72,  2,   73,  7,   73,  2,   74,  7,   74,
      2,   75,  7,   75,  2,   76,  7,   76,  2,   77,  7,   77,  2,   78,  7,   78,  2,   79,  7,
      79,  2,   80,  7,   80,  2,   81,  7,   81,  2,   82,  7,   82,  1,   0,   1,   0,   1,   0,
      1,   0,   3,   0,   171, 8,   0,   1,   0,   1,   0,   5,   0,   175, 8,   0,   10,  0,   12,
      0,   178, 9,   0,   1,   0,   1,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   1,
      2,   1,   2,   1,   2,   5,   2,   190, 8,   2,   10,  2,   12,  2,   193, 9,   2,   1,   2,
      1,   2,   1,   2,   1,   2,   3,   2,   199, 8,   2,   1,   2,   1,   2,   1,   3,   1,   3,
      3,   3,   205, 8,   3,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   5,   4,
      213, 8,   4,   10,  4,   12,  4,   216, 9,   4,   1,   4,   3,   4,   219, 8,   4,   1,   5,
      1,   5,   3,   5,   223, 8,   5,   1,   5,   1,   5,   1,   6,   1,   6,   1,   6,   1,   6,
      1,   6,   1,   6,   3,   6,   233, 8,   6,   1,   7,   1,   7,   3,   7,   237, 8,   7,   1,
      8,   1,   8,   1,   8,   1,   8,   1,   8,   1,   8,   1,   8,   3,   8,   246, 8,   8,   1,
      9,   1,   9,   1,   9,   1,   9,   1,   9,   1,   10,  1,   10,  1,   11,  1,   11,  1,   12,
      1,   12,  1,   12,  1,   13,  1,   13,  1,   13,  3,   13,  263, 8,   13,  1,   13,  5,   13,
      266, 8,   13,  10,  13,  12,  13,  269, 9,   13,  1,   13,  1,   13,  1,   14,  1,   14,  1,
      14,  1,   14,  1,   15,  1,   15,  1,   15,  1,   15,  1,   15,  1,   15,  1,   16,  1,   16,
      1,   16,  1,   16,  1,   16,  1,   16,  3,   16,  289, 8,   16,  1,   17,  1,   17,  1,   17,
      1,   18,  1,   18,  1,   18,  1,   18,  1,   18,  1,   18,  5,   18,  300, 8,   18,  10,  18,
      12,  18,  303, 9,   18,  1,   18,  3,   18,  306, 8,   18,  1,   19,  1,   19,  1,   19,  1,
      19,  3,   19,  312, 8,   19,  1,   19,  1,   19,  3,   19,  316, 8,   19,  1,   20,  1,   20,
      1,   20,  1,   20,  1,   20,  3,   20,  323, 8,   20,  1,   21,  1,   21,  3,   21,  327, 8,
      21,  1,   22,  1,   22,  1,   22,  1,   22,  5,   22,  333, 8,   22,  10,  22,  12,  22,  336,
      9,   22,  1,   22,  3,   22,  339, 8,   22,  3,   22,  341, 8,   22,  1,   22,  1,   22,  1,
      23,  1,   23,  1,   23,  1,   23,  1,   24,  1,   24,  3,   24,  351, 8,   24,  1,   24,  1,
      24,  3,   24,  355, 8,   24,  1,   24,  3,   24,  358, 8,   24,  1,   24,  1,   24,  1,   24,
      1,   24,  1,   24,  3,   24,  365, 8,   24,  1,   24,  1,   24,  1,   25,  1,   25,  1,   25,
      1,   25,  1,   25,  1,   26,  1,   26,  1,   26,  1,   26,  1,   26,  3,   26,  379, 8,   26,
      3,   26,  381, 8,   26,  1,   26,  3,   26,  384, 8,   26,  1,   26,  3,   26,  387, 8,   26,
      3,   26,  389, 8,   26,  1,   26,  1,   26,  1,   27,  1,   27,  1,   27,  1,   27,  1,   28,
      3,   28,  398, 8,   28,  1,   28,  3,   28,  401, 8,   28,  1,   28,  1,   28,  1,   29,  1,
      29,  1,   29,  1,   29,  3,   29,  409, 8,   29,  1,   29,  1,   29,  1,   29,  1,   29,  1,
      29,  1,   29,  1,   29,  1,   29,  1,   29,  1,   29,  1,   29,  1,   29,  1,   29,  1,   29,
      1,   29,  5,   29,  426, 8,   29,  10,  29,  12,  29,  429, 9,   29,  1,   30,  1,   30,  1,
      30,  1,   30,  3,   30,  435, 8,   30,  1,   30,  1,   30,  1,   30,  1,   30,  1,   30,  1,
      30,  1,   30,  3,   30,  444, 8,   30,  5,   30,  446, 8,   30,  10,  30,  12,  30,  449, 9,
      30,  1,   31,  1,   31,  1,   31,  1,   31,  3,   31,  455, 8,   31,  1,   31,  1,   31,  1,
      32,  1,   32,  1,   32,  1,   32,  1,   32,  3,   32,  464, 8,   32,  1,   33,  1,   33,  1,
      33,  1,   33,  1,   33,  1,   33,  3,   33,  472, 8,   33,  1,   34,  1,   34,  1,   34,  5,
      34,  477, 8,   34,  10,  34,  12,  34,  480, 9,   34,  1,   35,  1,   35,  1,   35,  5,   35,
      485, 8,   35,  10,  35,  12,  35,  488, 9,   35,  1,   36,  1,   36,  1,   36,  3,   36,  493,
      8,   36,  1,   37,  1,   37,  1,   38,  1,   38,  1,   39,  1,   39,  1,   39,  1,   39,  1,
      40,  1,   40,  1,   40,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,
      1,   41,  1,   41,  1,   41,  3,   41,  516, 8,   41,  1,   42,  1,   42,  1,   42,  3,   42,
      521, 8,   42,  3,   42,  523, 8,   42,  1,   42,  1,   42,  1,   43,  1,   43,  1,   43,  5,
      43,  530, 8,   43,  10,  43,  12,  43,  533, 9,   43,  1,   44,  1,   44,  1,   44,  3,   44,
      538, 8,   44,  1,   44,  1,   44,  1,   45,  1,   45,  3,   45,  544, 8,   45,  1,   46,  1,
      46,  3,   46,  548, 8,   46,  1,   47,  1,   47,  1,   47,  1,   47,  1,   47,  5,   47,  555,
      8,   47,  10,  47,  12,  47,  558, 9,   47,  1,   47,  1,   47,  1,   48,  1,   48,  1,   48,
      1,   48,  3,   48,  566, 8,   48,  1,   48,  3,   48,  569, 8,   48,  1,   49,  3,   49,  572,
      8,   49,  1,   49,  1,   49,  1,   50,  5,   50,  577, 8,   50,  10,  50,  12,  50,  580, 9,
      50,  1,   50,  1,   50,  1,   50,  1,   50,  1,   51,  1,   51,  1,   51,  1,   51,  3,   51,
      590, 8,   51,  1,   52,  1,   52,  3,   52,  594, 8,   52,  1,   52,  1,   52,  1,   53,  3,
      53,  599, 8,   53,  1,   53,  1,   53,  1,   53,  4,   53,  604, 8,   53,  11,  53,  12,  53,
      605, 1,   54,  1,   54,  1,   54,  1,   54,  1,   54,  1,   54,  1,   54,  1,   54,  1,   54,
      1,   54,  1,   54,  1,   54,  1,   54,  1,   54,  3,   54,  622, 8,   54,  1,   55,  1,   55,
      1,   55,  1,   55,  3,   55,  628, 8,   55,  1,   56,  1,   56,  1,   57,  1,   57,  1,   57,
      1,   58,  1,   58,  1,   58,  1,   58,  1,   59,  3,   59,  640, 8,   59,  1,   59,  1,   59,
      1,   60,  1,   60,  1,   60,  1,   60,  1,   61,  1,   61,  1,   62,  1,   62,  1,   62,  3,
      62,  653, 8,   62,  1,   63,  1,   63,  3,   63,  657, 8,   63,  1,   64,  1,   64,  3,   64,
      661, 8,   64,  1,   65,  1,   65,  3,   65,  665, 8,   65,  1,   66,  1,   66,  1,   66,  1,
      67,  1,   67,  1,   68,  1,   68,  1,   68,  1,   68,  1,   68,  1,   68,  1,   68,  1,   68,
      1,   68,  1,   68,  3,   68,  682, 8,   68,  1,   68,  1,   68,  1,   68,  1,   68,  1,   68,
      3,   68,  689, 8,   68,  3,   68,  691, 8,   68,  1,   69,  1,   69,  3,   69,  695, 8,   69,
      1,   70,  1,   70,  1,   70,  3,   70,  700, 8,   70,  1,   70,  3,   70,  703, 8,   70,  1,
      70,  1,   70,  3,   70,  707, 8,   70,  3,   70,  709, 8,   70,  1,   70,  1,   70,  1,   70,
      5,   70,  714, 8,   70,  10,  70,  12,  70,  717, 9,   70,  1,   70,  1,   70,  1,   71,  1,
      71,  1,   71,  3,   71,  724, 8,   71,  1,   72,  1,   72,  1,   72,  3,   72,  729, 8,   72,
      1,   73,  1,   73,  1,   73,  1,   73,  1,   73,  1,   73,  1,   73,  1,   73,  1,   73,  1,
      73,  3,   73,  741, 8,   73,  1,   73,  1,   73,  1,   73,  5,   73,  746, 8,   73,  10,  73,
      12,  73,  749, 9,   73,  1,   73,  1,   73,  1,   74,  1,   74,  3,   74,  755, 8,   74,  1,
      74,  1,   74,  1,   74,  1,   74,  1,   74,  1,   74,  1,   75,  1,   75,  1,   75,  3,   75,
      766, 8,   75,  1,   76,  1,   76,  1,   76,  3,   76,  771, 8,   76,  1,   77,  1,   77,  3,
      77,  775, 8,   77,  1,   77,  1,   77,  1,   77,  3,   77,  780, 8,   77,  5,   77,  782, 8,
      77,  10,  77,  12,  77,  785, 9,   77,  1,   78,  1,   78,  1,   78,  3,   78,  790, 8,   78,
      1,   78,  3,   78,  793, 8,   78,  1,   78,  1,   78,  1,   78,  1,   79,  3,   79,  799, 8,
      79,  1,   79,  1,   79,  3,   79,  803, 8,   79,  1,   79,  1,   79,  3,   79,  807, 8,   79,
      1,   80,  1,   80,  1,   80,  1,   80,  1,   80,  1,   80,  1,   81,  1,   81,  1,   81,  1,
      81,  1,   81,  1,   81,  1,   81,  1,   82,  1,   82,  1,   82,  0,   2,   58,  60,  83,  0,
      2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,  32,  34,  36,  38,
      40,  42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,
      78,  80,  82,  84,  86,  88,  90,  92,  94,  96,  98,  100, 102, 104, 106, 108, 110, 112, 114,
      116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
      154, 156, 158, 160, 162, 164, 0,   7,   3,   0,   49,  51,  54,  55,  58,  58,  3,   0,   51,
      53,  55,  55,  63,  64,  3,   0,   49,  50,  54,  54,  56,  56,  2,   0,   61,  62,  65,  68,
      2,   0,   1,   4,   22,  22,  1,   0,   71,  71,  2,   0,   49,  56,  63,  64,  870, 0,   166,
      1,   0,   0,   0,   2,   181, 1,   0,   0,   0,   4,   185, 1,   0,   0,   0,   6,   204, 1,
      0,   0,   0,   8,   206, 1,   0,   0,   0,   10,  220, 1,   0,   0,   0,   12,  232, 1,   0,
      0,   0,   14,  236, 1,   0,   0,   0,   16,  245, 1,   0,   0,   0,   18,  247, 1,   0,   0,
      0,   20,  252, 1,   0,   0,   0,   22,  254, 1,   0,   0,   0,   24,  256, 1,   0,   0,   0,
      26,  259, 1,   0,   0,   0,   28,  272, 1,   0,   0,   0,   30,  276, 1,   0,   0,   0,   32,
      288, 1,   0,   0,   0,   34,  290, 1,   0,   0,   0,   36,  293, 1,   0,   0,   0,   38,  307,
      1,   0,   0,   0,   40,  322, 1,   0,   0,   0,   42,  326, 1,   0,   0,   0,   44,  328, 1,
      0,   0,   0,   46,  344, 1,   0,   0,   0,   48,  348, 1,   0,   0,   0,   50,  368, 1,   0,
      0,   0,   52,  373, 1,   0,   0,   0,   54,  392, 1,   0,   0,   0,   56,  397, 1,   0,   0,
      0,   58,  408, 1,   0,   0,   0,   60,  434, 1,   0,   0,   0,   62,  450, 1,   0,   0,   0,
      64,  463, 1,   0,   0,   0,   66,  471, 1,   0,   0,   0,   68,  473, 1,   0,   0,   0,   70,
      481, 1,   0,   0,   0,   72,  492, 1,   0,   0,   0,   74,  494, 1,   0,   0,   0,   76,  496,
      1,   0,   0,   0,   78,  498, 1,   0,   0,   0,   80,  502, 1,   0,   0,   0,   82,  515, 1,
      0,   0,   0,   84,  517, 1,   0,   0,   0,   86,  526, 1,   0,   0,   0,   88,  537, 1,   0,
      0,   0,   90,  543, 1,   0,   0,   0,   92,  547, 1,   0,   0,   0,   94,  549, 1,   0,   0,
      0,   96,  565, 1,   0,   0,   0,   98,  571, 1,   0,   0,   0,   100, 578, 1,   0,   0,   0,
      102, 585, 1,   0,   0,   0,   104, 591, 1,   0,   0,   0,   106, 603, 1,   0,   0,   0,   108,
      621, 1,   0,   0,   0,   110, 627, 1,   0,   0,   0,   112, 629, 1,   0,   0,   0,   114, 631,
      1,   0,   0,   0,   116, 634, 1,   0,   0,   0,   118, 639, 1,   0,   0,   0,   120, 643, 1,
      0,   0,   0,   122, 647, 1,   0,   0,   0,   124, 649, 1,   0,   0,   0,   126, 654, 1,   0,
      0,   0,   128, 658, 1,   0,   0,   0,   130, 662, 1,   0,   0,   0,   132, 666, 1,   0,   0,
      0,   134, 669, 1,   0,   0,   0,   136, 671, 1,   0,   0,   0,   138, 694, 1,   0,   0,   0,
      140, 696, 1,   0,   0,   0,   142, 720, 1,   0,   0,   0,   144, 728, 1,   0,   0,   0,   146,
      730, 1,   0,   0,   0,   148, 754, 1,   0,   0,   0,   150, 762, 1,   0,   0,   0,   152, 770,
      1,   0,   0,   0,   154, 774, 1,   0,   0,   0,   156, 786, 1,   0,   0,   0,   158, 798, 1,
      0,   0,   0,   160, 808, 1,   0,   0,   0,   162, 814, 1,   0,   0,   0,   164, 821, 1,   0,
      0,   0,   166, 167, 3,   2,   1,   0,   167, 176, 3,   164, 82,  0,   168, 171, 3,   102, 51,
      0,   169, 171, 3,   6,   3,   0,   170, 168, 1,   0,   0,   0,   170, 169, 1,   0,   0,   0,
      171, 172, 1,   0,   0,   0,   172, 173, 3,   164, 82,  0,   173, 175, 1,   0,   0,   0,   174,
      170, 1,   0,   0,   0,   175, 178, 1,   0,   0,   0,   176, 174, 1,   0,   0,   0,   176, 177,
      1,   0,   0,   0,   177, 179, 1,   0,   0,   0,   178, 176, 1,   0,   0,   0,   179, 180, 5,
      0,   0,   1,   180, 1,   1,   0,   0,   0,   181, 182, 5,   79,  0,   0,   182, 183, 5,   39,
      0,   0,   183, 184, 5,   4,   0,   0,   184, 3,   1,   0,   0,   0,   185, 186, 5,   79,  0,
      0,   186, 191, 5,   83,  0,   0,   187, 188, 9,   0,   0,   0,   188, 190, 5,   83,  0,   0,
      189, 187, 1,   0,   0,   0,   190, 193, 1,   0,   0,   0,   191, 189, 1,   0,   0,   0,   191,
      192, 1,   0,   0,   0,   192, 198, 1,   0,   0,   0,   193, 191, 1,   0,   0,   0,   194, 195,
      5,   59,  0,   0,   195, 199, 5,   20,  0,   0,   196, 199, 5,   19,  0,   0,   197, 199, 5,
      4,   0,   0,   198, 194, 1,   0,   0,   0,   198, 196, 1,   0,   0,   0,   198, 197, 1,   0,
      0,   0,   198, 199, 1,   0,   0,   0,   199, 200, 1,   0,   0,   0,   200, 201, 5,   80,  0,
      0,   201, 5,   1,   0,   0,   0,   202, 205, 3,   8,   4,   0,   203, 205, 3,   36,  18,  0,
      204, 202, 1,   0,   0,   0,   204, 203, 1,   0,   0,   0,   205, 7,   1,   0,   0,   0,   206,
      218, 5,   38,  0,   0,   207, 219, 3,   10,  5,   0,   208, 214, 5,   43,  0,   0,   209, 210,
      3,   10,  5,   0,   210, 211, 3,   164, 82,  0,   211, 213, 1,   0,   0,   0,   212, 209, 1,
      0,   0,   0,   213, 216, 1,   0,   0,   0,   214, 212, 1,   0,   0,   0,   214, 215, 1,   0,
      0,   0,   215, 217, 1,   0,   0,   0,   216, 214, 1,   0,   0,   0,   217, 219, 5,   44,  0,
      0,   218, 207, 1,   0,   0,   0,   218, 208, 1,   0,   0,   0,   219, 9,   1,   0,   0,   0,
      220, 222, 5,   83,  0,   0,   221, 223, 5,   59,  0,   0,   222, 221, 1,   0,   0,   0,   222,
      223, 1,   0,   0,   0,   223, 224, 1,   0,   0,   0,   224, 225, 3,   12,  6,   0,   225, 11,
      1,   0,   0,   0,   226, 233, 3,   14,  7,   0,   227, 233, 3,   16,  8,   0,   228, 229, 5,
      43,  0,   0,   229, 230, 3,   12,  6,   0,   230, 231, 5,   44,  0,   0,   231, 233, 1,   0,
      0,   0,   232, 226, 1,   0,   0,   0,   232, 227, 1,   0,   0,   0,   232, 228, 1,   0,   0,
      0,   233, 13,  1,   0,   0,   0,   234, 237, 3,   78,  39,  0,   235, 237, 5,   83,  0,   0,
      236, 234, 1,   0,   0,   0,   236, 235, 1,   0,   0,   0,   237, 15,  1,   0,   0,   0,   238,
      246, 3,   18,  9,   0,   239, 246, 3,   94,  47,  0,   240, 246, 3,   24,  12,  0,   241, 246,
      3,   34,  17,  0,   242, 246, 3,   26,  13,  0,   243, 246, 3,   28,  14,  0,   244, 246, 3,
      30,  15,  0,   245, 238, 1,   0,   0,   0,   245, 239, 1,   0,   0,   0,   245, 240, 1,   0,
      0,   0,   245, 241, 1,   0,   0,   0,   245, 242, 1,   0,   0,   0,   245, 243, 1,   0,   0,
      0,   245, 244, 1,   0,   0,   0,   246, 17,  1,   0,   0,   0,   247, 248, 5,   45,  0,   0,
      248, 249, 3,   20,  10,  0,   249, 250, 5,   46,  0,   0,   250, 251, 3,   22,  11,  0,   251,
      19,  1,   0,   0,   0,   252, 253, 3,   58,  29,  0,   253, 21,  1,   0,   0,   0,   254, 255,
      3,   12,  6,   0,   255, 23,  1,   0,   0,   0,   256, 257, 5,   51,  0,   0,   257, 258, 3,
      12,  6,   0,   258, 25,  1,   0,   0,   0,   259, 260, 5,   40,  0,   0,   260, 267, 5,   47,
      0,   0,   261, 263, 5,   41,  0,   0,   262, 261, 1,   0,   0,   0,   262, 263, 1,   0,   0,
      0,   263, 264, 1,   0,   0,   0,   264, 266, 3,   100, 50,  0,   265, 262, 1,   0,   0,   0,
      266, 269, 1,   0,   0,   0,   267, 265, 1,   0,   0,   0,   267, 268, 1,   0,   0,   0,   268,
      270, 1,   0,   0,   0,   269, 267, 1,   0,   0,   0,   270, 271, 5,   48,  0,   0,   271, 27,
      1,   0,   0,   0,   272, 273, 5,   45,  0,   0,   273, 274, 5,   46,  0,   0,   274, 275, 3,
      22,  11,  0,   275, 29,  1,   0,   0,   0,   276, 277, 5,   81,  0,   0,   277, 278, 5,   45,
      0,   0,   278, 279, 3,   12,  6,   0,   279, 280, 5,   46,  0,   0,   280, 281, 3,   22,  11,
      0,   281, 31,  1,   0,   0,   0,   282, 283, 5,   83,  0,   0,   283, 284, 3,   44,  22,  0,
      284, 285, 3,   42,  21,  0,   285, 289, 1,   0,   0,   0,   286, 287, 5,   83,  0,   0,   287,
      289, 3,   44,  22,  0,   288, 282, 1,   0,   0,   0,   288, 286, 1,   0,   0,   0,   289, 33,
      1,   0,   0,   0,   290, 291, 5,   35,  0,   0,   291, 292, 3,   40,  20,  0,   292, 35,  1,
      0,   0,   0,   293, 305, 5,   18,  0,   0,   294, 306, 3,   38,  19,  0,   295, 301, 5,   43,
      0,   0,   296, 297, 3,   38,  19,  0,   297, 298, 3,   164, 82,  0,   298, 300, 1,   0,   0,
      0,   299, 296, 1,   0,   0,   0,   300, 303, 1,   0,   0,   0,   301, 299, 1,   0,   0,   0,
      301, 302, 1,   0,   0,   0,   302, 304, 1,   0,   0,   0,   303, 301, 1,   0,   0,   0,   304,
      306, 5,   44,  0,   0,   305, 294, 1,   0,   0,   0,   305, 295, 1,   0,   0,   0,   306, 37,
      1,   0,   0,   0,   307, 315, 3,   70,  35,  0,   308, 311, 3,   12,  6,   0,   309, 310, 5,
      59,  0,   0,   310, 312, 3,   68,  34,  0,   311, 309, 1,   0,   0,   0,   311, 312, 1,   0,
      0,   0,   312, 316, 1,   0,   0,   0,   313, 314, 5,   59,  0,   0,   314, 316, 3,   68,  34,
      0,   315, 308, 1,   0,   0,   0,   315, 313, 1,   0,   0,   0,   316, 39,  1,   0,   0,   0,
      317, 318, 3,   44,  22,  0,   318, 319, 5,   74,  0,   0,   319, 320, 3,   42,  21,  0,   320,
      323, 1,   0,   0,   0,   321, 323, 3,   44,  22,  0,   322, 317, 1,   0,   0,   0,   322, 321,
      1,   0,   0,   0,   323, 41,  1,   0,   0,   0,   324, 327, 3,   44,  22,  0,   325, 327, 3,
      12,  6,   0,   326, 324, 1,   0,   0,   0,   326, 325, 1,   0,   0,   0,   327, 43,  1,   0,
      0,   0,   328, 340, 5,   43,  0,   0,   329, 334, 3,   56,  28,  0,   330, 331, 5,   73,  0,
      0,   331, 333, 3,   56,  28,  0,   332, 330, 1,   0,   0,   0,   333, 336, 1,   0,   0,   0,
      334, 332, 1,   0,   0,   0,   334, 335, 1,   0,   0,   0,   335, 338, 1,   0,   0,   0,   336,
      334, 1,   0,   0,   0,   337, 339, 5,   73,  0,   0,   338, 337, 1,   0,   0,   0,   338, 339,
      1,   0,   0,   0,   339, 341, 1,   0,   0,   0,   340, 329, 1,   0,   0,   0,   340, 341, 1,
      0,   0,   0,   341, 342, 1,   0,   0,   0,   342, 343, 5,   44,  0,   0,   343, 45,  1,   0,
      0,   0,   344, 345, 5,   45,  0,   0,   345, 346, 3,   58,  29,  0,   346, 347, 5,   46,  0,
      0,   347, 47,  1,   0,   0,   0,   348, 364, 5,   45,  0,   0,   349, 351, 3,   58,  29,  0,
      350, 349, 1,   0,   0,   0,   350, 351, 1,   0,   0,   0,   351, 352, 1,   0,   0,   0,   352,
      354, 5,   75,  0,   0,   353, 355, 3,   58,  29,  0,   354, 353, 1,   0,   0,   0,   354, 355,
      1,   0,   0,   0,   355, 365, 1,   0,   0,   0,   356, 358, 3,   58,  29,  0,   357, 356, 1,
      0,   0,   0,   357, 358, 1,   0,   0,   0,   358, 359, 1,   0,   0,   0,   359, 360, 5,   75,
      0,   0,   360, 361, 3,   58,  29,  0,   361, 362, 5,   75,  0,   0,   362, 363, 3,   58,  29,
      0,   363, 365, 1,   0,   0,   0,   364, 350, 1,   0,   0,   0,   364, 357, 1,   0,   0,   0,
      365, 366, 1,   0,   0,   0,   366, 367, 5,   46,  0,   0,   367, 49,  1,   0,   0,   0,   368,
      369, 5,   76,  0,   0,   369, 370, 5,   43,  0,   0,   370, 371, 3,   12,  6,   0,   371, 372,
      5,   44,  0,   0,   372, 51,  1,   0,   0,   0,   373, 388, 5,   43,  0,   0,   374, 381, 3,
      68,  34,  0,   375, 378, 3,   64,  32,  0,   376, 377, 5,   73,  0,   0,   377, 379, 3,   68,
      34,  0,   378, 376, 1,   0,   0,   0,   378, 379, 1,   0,   0,   0,   379, 381, 1,   0,   0,
      0,   380, 374, 1,   0,   0,   0,   380, 375, 1,   0,   0,   0,   381, 383, 1,   0,   0,   0,
      382, 384, 5,   82,  0,   0,   383, 382, 1,   0,   0,   0,   383, 384, 1,   0,   0,   0,   384,
      386, 1,   0,   0,   0,   385, 387, 5,   73,  0,   0,   386, 385, 1,   0,   0,   0,   386, 387,
      1,   0,   0,   0,   387, 389, 1,   0,   0,   0,   388, 380, 1,   0,   0,   0,   388, 389, 1,
      0,   0,   0,   389, 390, 1,   0,   0,   0,   390, 391, 5,   44,  0,   0,   391, 53,  1,   0,
      0,   0,   392, 393, 3,   64,  32,  0,   393, 394, 5,   76,  0,   0,   394, 395, 5,   83,  0,
      0,   395, 55,  1,   0,   0,   0,   396, 398, 3,   70,  35,  0,   397, 396, 1,   0,   0,   0,
      397, 398, 1,   0,   0,   0,   398, 400, 1,   0,   0,   0,   399, 401, 5,   82,  0,   0,   400,
      399, 1,   0,   0,   0,   400, 401, 1,   0,   0,   0,   401, 402, 1,   0,   0,   0,   402, 403,
      3,   12,  6,   0,   403, 57,  1,   0,   0,   0,   404, 405, 6,   29,  -1,  0,   405, 409, 3,
      60,  30,  0,   406, 407, 7,   0,   0,   0,   407, 409, 3,   58,  29,  6,   408, 404, 1,   0,
      0,   0,   408, 406, 1,   0,   0,   0,   409, 427, 1,   0,   0,   0,   410, 411, 10,  5,   0,
      0,   411, 412, 7,   1,   0,   0,   412, 426, 3,   58,  29,  6,   413, 414, 10,  4,   0,   0,
      414, 415, 7,   2,   0,   0,   415, 426, 3,   58,  29,  5,   416, 417, 10,  3,   0,   0,   417,
      418, 7,   3,   0,   0,   418, 426, 3,   58,  29,  4,   419, 420, 10,  2,   0,   0,   420, 421,
      5,   69,  0,   0,   421, 426, 3,   58,  29,  3,   422, 423, 10,  1,   0,   0,   423, 424, 5,
      70,  0,   0,   424, 426, 3,   58,  29,  2,   425, 410, 1,   0,   0,   0,   425, 413, 1,   0,
      0,   0,   425, 416, 1,   0,   0,   0,   425, 419, 1,   0,   0,   0,   425, 422, 1,   0,   0,
      0,   426, 429, 1,   0,   0,   0,   427, 425, 1,   0,   0,   0,   427, 428, 1,   0,   0,   0,
      428, 59,  1,   0,   0,   0,   429, 427, 1,   0,   0,   0,   430, 431, 6,   30,  -1,  0,   431,
      435, 3,   66,  33,  0,   432, 435, 3,   62,  31,  0,   433, 435, 3,   54,  27,  0,   434, 430,
      1,   0,   0,   0,   434, 432, 1,   0,   0,   0,   434, 433, 1,   0,   0,   0,   435, 447, 1,
      0,   0,   0,   436, 443, 10,  1,   0,   0,   437, 438, 5,   76,  0,   0,   438, 444, 5,   83,
      0,   0,   439, 444, 3,   46,  23,  0,   440, 444, 3,   48,  24,  0,   441, 444, 3,   50,  25,
      0,   442, 444, 3,   52,  26,  0,   443, 437, 1,   0,   0,   0,   443, 439, 1,   0,   0,   0,
      443, 440, 1,   0,   0,   0,   443, 441, 1,   0,   0,   0,   443, 442, 1,   0,   0,   0,   444,
      446, 1,   0,   0,   0,   445, 436, 1,   0,   0,   0,   446, 449, 1,   0,   0,   0,   447, 445,
      1,   0,   0,   0,   447, 448, 1,   0,   0,   0,   448, 61,  1,   0,   0,   0,   449, 447, 1,
      0,   0,   0,   450, 451, 3,   64,  32,  0,   451, 452, 5,   43,  0,   0,   452, 454, 3,   58,
      29,  0,   453, 455, 5,   73,  0,   0,   454, 453, 1,   0,   0,   0,   454, 455, 1,   0,   0,
      0,   455, 456, 1,   0,   0,   0,   456, 457, 5,   44,  0,   0,   457, 63,  1,   0,   0,   0,
      458, 464, 3,   16,  8,   0,   459, 460, 5,   43,  0,   0,   460, 461, 3,   64,  32,  0,   461,
      462, 5,   44,  0,   0,   462, 464, 1,   0,   0,   0,   463, 458, 1,   0,   0,   0,   463, 459,
      1,   0,   0,   0,   464, 65,  1,   0,   0,   0,   465, 472, 3,   72,  36,  0,   466, 472, 3,
      76,  38,  0,   467, 468, 5,   43,  0,   0,   468, 469, 3,   58,  29,  0,   469, 470, 5,   44,
      0,   0,   470, 472, 1,   0,   0,   0,   471, 465, 1,   0,   0,   0,   471, 466, 1,   0,   0,
      0,   471, 467, 1,   0,   0,   0,   472, 67,  1,   0,   0,   0,   473, 478, 3,   58,  29,  0,
      474, 475, 5,   73,  0,   0,   475, 477, 3,   58,  29,  0,   476, 474, 1,   0,   0,   0,   477,
      480, 1,   0,   0,   0,   478, 476, 1,   0,   0,   0,   478, 479, 1,   0,   0,   0,   479, 69,
      1,   0,   0,   0,   480, 478, 1,   0,   0,   0,   481, 486, 5,   83,  0,   0,   482, 483, 5,
      73,  0,   0,   483, 485, 5,   83,  0,   0,   484, 482, 1,   0,   0,   0,   485, 488, 1,   0,
      0,   0,   486, 484, 1,   0,   0,   0,   486, 487, 1,   0,   0,   0,   487, 71,  1,   0,   0,
      0,   488, 486, 1,   0,   0,   0,   489, 493, 3,   74,  37,  0,   490, 493, 3,   80,  40,  0,
      491, 493, 3,   100, 50,  0,   492, 489, 1,   0,   0,   0,   492, 490, 1,   0,   0,   0,   492,
      491, 1,   0,   0,   0,   493, 73,  1,   0,   0,   0,   494, 495, 7,   4,   0,   0,   495, 75,
      1,   0,   0,   0,   496, 497, 5,   83,  0,   0,   497, 77,  1,   0,   0,   0,   498, 499, 5,
      83,  0,   0,   499, 500, 5,   76,  0,   0,   500, 501, 5,   83,  0,   0,   501, 79,  1,   0,
      0,   0,   502, 503, 3,   82,  41,  0,   503, 504, 3,   84,  42,  0,   504, 81,  1,   0,   0,
      0,   505, 516, 3,   94,  47,  0,   506, 516, 3,   18,  9,   0,   507, 508, 3,   22,  11,  0,
      508, 509, 5,   45,  0,   0,   509, 510, 5,   82,  0,   0,   510, 511, 5,   46,  0,   0,   511,
      516, 1,   0,   0,   0,   512, 516, 3,   28,  14,  0,   513, 516, 3,   30,  15,  0,   514, 516,
      3,   14,  7,   0,   515, 505, 1,   0,   0,   0,   515, 506, 1,   0,   0,   0,   515, 507, 1,
      0,   0,   0,   515, 512, 1,   0,   0,   0,   515, 513, 1,   0,   0,   0,   515, 514, 1,   0,
      0,   0,   516, 83,  1,   0,   0,   0,   517, 522, 5,   47,  0,   0,   518, 520, 3,   86,  43,
      0,   519, 521, 5,   73,  0,   0,   520, 519, 1,   0,   0,   0,   520, 521, 1,   0,   0,   0,
      521, 523, 1,   0,   0,   0,   522, 518, 1,   0,   0,   0,   522, 523, 1,   0,   0,   0,   523,
      524, 1,   0,   0,   0,   524, 525, 5,   48,  0,   0,   525, 85,  1,   0,   0,   0,   526, 531,
      3,   88,  44,  0,   527, 528, 5,   73,  0,   0,   528, 530, 3,   88,  44,  0,   529, 527, 1,
      0,   0,   0,   530, 533, 1,   0,   0,   0,   531, 529, 1,   0,   0,   0,   531, 532, 1,   0,
      0,   0,   532, 87,  1,   0,   0,   0,   533, 531, 1,   0,   0,   0,   534, 535, 3,   90,  45,
      0,   535, 536, 5,   75,  0,   0,   536, 538, 1,   0,   0,   0,   537, 534, 1,   0,   0,   0,
      537, 538, 1,   0,   0,   0,   538, 539, 1,   0,   0,   0,   539, 540, 3,   92,  46,  0,   540,
      89,  1,   0,   0,   0,   541, 544, 3,   58,  29,  0,   542, 544, 3,   84,  42,  0,   543, 541,
      1,   0,   0,   0,   543, 542, 1,   0,   0,   0,   544, 91,  1,   0,   0,   0,   545, 548, 3,
      58,  29,  0,   546, 548, 3,   84,  42,  0,   547, 545, 1,   0,   0,   0,   547, 546, 1,   0,
      0,   0,   548, 93,  1,   0,   0,   0,   549, 550, 5,   37,  0,   0,   550, 556, 5,   47,  0,
      0,   551, 552, 3,   96,  48,  0,   552, 553, 3,   164, 82,  0,   553, 555, 1,   0,   0,   0,
      554, 551, 1,   0,   0,   0,   555, 558, 1,   0,   0,   0,   556, 554, 1,   0,   0,   0,   556,
      557, 1,   0,   0,   0,   557, 559, 1,   0,   0,   0,   558, 556, 1,   0,   0,   0,   559, 560,
      5,   48,  0,   0,   560, 95,  1,   0,   0,   0,   561, 562, 3,   70,  35,  0,   562, 563, 3,
      12,  6,   0,   563, 566, 1,   0,   0,   0,   564, 566, 3,   98,  49,  0,   565, 561, 1,   0,
      0,   0,   565, 564, 1,   0,   0,   0,   566, 568, 1,   0,   0,   0,   567, 569, 5,   4,   0,
      0,   568, 567, 1,   0,   0,   0,   568, 569, 1,   0,   0,   0,   569, 97,  1,   0,   0,   0,
      570, 572, 5,   51,  0,   0,   571, 570, 1,   0,   0,   0,   571, 572, 1,   0,   0,   0,   572,
      573, 1,   0,   0,   0,   573, 574, 3,   14,  7,   0,   574, 99,  1,   0,   0,   0,   575, 577,
      3,   4,   2,   0,   576, 575, 1,   0,   0,   0,   577, 580, 1,   0,   0,   0,   578, 576, 1,
      0,   0,   0,   578, 579, 1,   0,   0,   0,   579, 581, 1,   0,   0,   0,   580, 578, 1,   0,
      0,   0,   581, 582, 5,   35,  0,   0,   582, 583, 3,   40,  20,  0,   583, 584, 3,   104, 52,
      0,   584, 101, 1,   0,   0,   0,   585, 586, 5,   35,  0,   0,   586, 587, 5,   83,  0,   0,
      587, 589, 3,   40,  20,  0,   588, 590, 3,   104, 52,  0,   589, 588, 1,   0,   0,   0,   589,
      590, 1,   0,   0,   0,   590, 103, 1,   0,   0,   0,   591, 593, 5,   47,  0,   0,   592, 594,
      3,   106, 53,  0,   593, 592, 1,   0,   0,   0,   593, 594, 1,   0,   0,   0,   594, 595, 1,
      0,   0,   0,   595, 596, 5,   48,  0,   0,   596, 105, 1,   0,   0,   0,   597, 599, 5,   80,
      0,   0,   598, 597, 1,   0,   0,   0,   598, 599, 1,   0,   0,   0,   599, 600, 1,   0,   0,
      0,   600, 601, 3,   108, 54,  0,   601, 602, 3,   164, 82,  0,   602, 604, 1,   0,   0,   0,
      603, 598, 1,   0,   0,   0,   604, 605, 1,   0,   0,   0,   605, 603, 1,   0,   0,   0,   605,
      606, 1,   0,   0,   0,   606, 107, 1,   0,   0,   0,   607, 622, 3,   6,   3,   0,   608, 622,
      3,   124, 62,  0,   609, 622, 3,   110, 55,  0,   610, 622, 3,   126, 63,  0,   611, 622, 3,
      128, 64,  0,   612, 622, 3,   130, 65,  0,   613, 622, 3,   132, 66,  0,   614, 622, 3,   134,
      67,  0,   615, 622, 3,   104, 52,  0,   616, 622, 3,   136, 68,  0,   617, 622, 3,   138, 69,
      0,   618, 622, 3,   156, 78,  0,   619, 622, 3,   160, 80,  0,   620, 622, 3,   162, 81,  0,
      621, 607, 1,   0,   0,   0,   621, 608, 1,   0,   0,   0,   621, 609, 1,   0,   0,   0,   621,
      610, 1,   0,   0,   0,   621, 611, 1,   0,   0,   0,   621, 612, 1,   0,   0,   0,   621, 613,
      1,   0,   0,   0,   621, 614, 1,   0,   0,   0,   621, 615, 1,   0,   0,   0,   621, 616, 1,
      0,   0,   0,   621, 617, 1,   0,   0,   0,   621, 618, 1,   0,   0,   0,   621, 619, 1,   0,
      0,   0,   621, 620, 1,   0,   0,   0,   622, 109, 1,   0,   0,   0,   623, 628, 3,   114, 57,
      0,   624, 628, 3,   116, 58,  0,   625, 628, 3,   112, 56,  0,   626, 628, 3,   120, 60,  0,
      627, 623, 1,   0,   0,   0,   627, 624, 1,   0,   0,   0,   627, 625, 1,   0,   0,   0,   627,
      626, 1,   0,   0,   0,   628, 111, 1,   0,   0,   0,   629, 630, 3,   58,  29,  0,   630, 113,
      1,   0,   0,   0,   631, 632, 3,   58,  29,  0,   632, 633, 7,   5,   0,   0,   633, 115, 1,
      0,   0,   0,   634, 635, 3,   68,  34,  0,   635, 636, 3,   118, 59,  0,   636, 637, 3,   68,
      34,  0,   637, 117, 1,   0,   0,   0,   638, 640, 7,   6,   0,   0,   639, 638, 1,   0,   0,
      0,   639, 640, 1,   0,   0,   0,   640, 641, 1,   0,   0,   0,   641, 642, 5,   66,  0,   0,
      642, 119, 1,   0,   0,   0,   643, 644, 3,   70,  35,  0,   644, 645, 5,   60,  0,   0,   645,
      646, 3,   68,  34,  0,   646, 121, 1,   0,   0,   0,   647, 648, 5,   80,  0,   0,   648, 123,
      1,   0,   0,   0,   649, 650, 5,   83,  0,   0,   650, 652, 5,   75,  0,   0,   651, 653, 3,
      108, 54,  0,   652, 651, 1,   0,   0,   0,   652, 653, 1,   0,   0,   0,   653, 125, 1,   0,
      0,   0,   654, 656, 5,   36,  0,   0,   655, 657, 3,   68,  34,  0,   656, 655, 1,   0,   0,
      0,   656, 657, 1,   0,   0,   0,   657, 127, 1,   0,   0,   0,   658, 660, 5,   23,  0,   0,
      659, 661, 5,   83,  0,   0,   660, 659, 1,   0,   0,   0,   660, 661, 1,   0,   0,   0,   661,
      129, 1,   0,   0,   0,   662, 664, 5,   24,  0,   0,   663, 665, 5,   83,  0,   0,   664, 663,
      1,   0,   0,   0,   664, 665, 1,   0,   0,   0,   665, 131, 1,   0,   0,   0,   666, 667, 5,
      25,  0,   0,   667, 668, 5,   83,  0,   0,   668, 133, 1,   0,   0,   0,   669, 670, 5,   26,
      0,   0,   670, 135, 1,   0,   0,   0,   671, 672, 5,   27,  0,   0,   672, 681, 5,   43,  0,
      0,   673, 682, 3,   58,  29,  0,   674, 675, 3,   164, 82,  0,   675, 676, 3,   58,  29,  0,
      676, 682, 1,   0,   0,   0,   677, 678, 3,   110, 55,  0,   678, 679, 3,   164, 82,  0,   679,
      680, 3,   58,  29,  0,   680, 682, 1,   0,   0,   0,   681, 673, 1,   0,   0,   0,   681, 674,
      1,   0,   0,   0,   681, 677, 1,   0,   0,   0,   682, 683, 1,   0,   0,   0,   683, 684, 5,
      44,  0,   0,   684, 690, 3,   104, 52,  0,   685, 688, 5,   30,  0,   0,   686, 689, 3,   136,
      68,  0,   687, 689, 3,   104, 52,  0,   688, 686, 1,   0,   0,   0,   688, 687, 1,   0,   0,
      0,   689, 691, 1,   0,   0,   0,   690, 685, 1,   0,   0,   0,   690, 691, 1,   0,   0,   0,
      691, 137, 1,   0,   0,   0,   692, 695, 3,   140, 70,  0,   693, 695, 3,   146, 73,  0,   694,
      692, 1,   0,   0,   0,   694, 693, 1,   0,   0,   0,   695, 139, 1,   0,   0,   0,   696, 697,
      5,   32,  0,   0,   697, 708, 5,   43,  0,   0,   698, 700, 3,   58,  29,  0,   699, 698, 1,
      0,   0,   0,   699, 700, 1,   0,   0,   0,   700, 709, 1,   0,   0,   0,   701, 703, 3,   110,
      55,  0,   702, 701, 1,   0,   0,   0,   702, 703, 1,   0,   0,   0,   703, 704, 1,   0,   0,
      0,   704, 706, 3,   164, 82,  0,   705, 707, 3,   58,  29,  0,   706, 705, 1,   0,   0,   0,
      706, 707, 1,   0,   0,   0,   707, 709, 1,   0,   0,   0,   708, 699, 1,   0,   0,   0,   708,
      702, 1,   0,   0,   0,   709, 710, 1,   0,   0,   0,   710, 711, 5,   44,  0,   0,   711, 715,
      5,   47,  0,   0,   712, 714, 3,   142, 71,  0,   713, 712, 1,   0,   0,   0,   714, 717, 1,
      0,   0,   0,   715, 713, 1,   0,   0,   0,   715, 716, 1,   0,   0,   0,   716, 718, 1,   0,
      0,   0,   717, 715, 1,   0,   0,   0,   718, 719, 5,   48,  0,   0,   719, 141, 1,   0,   0,
      0,   720, 721, 3,   144, 72,  0,   721, 723, 5,   75,  0,   0,   722, 724, 3,   106, 53,  0,
      723, 722, 1,   0,   0,   0,   723, 724, 1,   0,   0,   0,   724, 143, 1,   0,   0,   0,   725,
      726, 5,   33,  0,   0,   726, 729, 3,   68,  34,  0,   727, 729, 5,   34,  0,   0,   728, 725,
      1,   0,   0,   0,   728, 727, 1,   0,   0,   0,   729, 145, 1,   0,   0,   0,   730, 731, 5,
      32,  0,   0,   731, 740, 5,   43,  0,   0,   732, 741, 3,   148, 74,  0,   733, 734, 3,   164,
      82,  0,   734, 735, 3,   148, 74,  0,   735, 741, 1,   0,   0,   0,   736, 737, 3,   110, 55,
      0,   737, 738, 3,   164, 82,  0,   738, 739, 3,   148, 74,  0,   739, 741, 1,   0,   0,   0,
      740, 732, 1,   0,   0,   0,   740, 733, 1,   0,   0,   0,   740, 736, 1,   0,   0,   0,   741,
      742, 1,   0,   0,   0,   742, 743, 5,   44,  0,   0,   743, 747, 5,   47,  0,   0,   744, 746,
      3,   150, 75,  0,   745, 744, 1,   0,   0,   0,   746, 749, 1,   0,   0,   0,   747, 745, 1,
      0,   0,   0,   747, 748, 1,   0,   0,   0,   748, 750, 1,   0,   0,   0,   749, 747, 1,   0,
      0,   0,   750, 751, 5,   48,  0,   0,   751, 147, 1,   0,   0,   0,   752, 753, 5,   83,  0,
      0,   753, 755, 5,   60,  0,   0,   754, 752, 1,   0,   0,   0,   754, 755, 1,   0,   0,   0,
      755, 756, 1,   0,   0,   0,   756, 757, 3,   60,  30,  0,   757, 758, 5,   76,  0,   0,   758,
      759, 5,   43,  0,   0,   759, 760, 5,   38,  0,   0,   760, 761, 5,   44,  0,   0,   761, 149,
      1,   0,   0,   0,   762, 763, 3,   152, 76,  0,   763, 765, 5,   75,  0,   0,   764, 766, 3,
      106, 53,  0,   765, 764, 1,   0,   0,   0,   765, 766, 1,   0,   0,   0,   766, 151, 1,   0,
      0,   0,   767, 768, 5,   33,  0,   0,   768, 771, 3,   154, 77,  0,   769, 771, 5,   34,  0,
      0,   770, 767, 1,   0,   0,   0,   770, 769, 1,   0,   0,   0,   771, 153, 1,   0,   0,   0,
      772, 775, 3,   12,  6,   0,   773, 775, 5,   22,  0,   0,   774, 772, 1,   0,   0,   0,   774,
      773, 1,   0,   0,   0,   775, 783, 1,   0,   0,   0,   776, 779, 5,   73,  0,   0,   777, 780,
      3,   12,  6,   0,   778, 780, 5,   22,  0,   0,   779, 777, 1,   0,   0,   0,   779, 778, 1,
      0,   0,   0,   780, 782, 1,   0,   0,   0,   781, 776, 1,   0,   0,   0,   782, 785, 1,   0,
      0,   0,   783, 781, 1,   0,   0,   0,   783, 784, 1,   0,   0,   0,   784, 155, 1,   0,   0,
      0,   785, 783, 1,   0,   0,   0,   786, 787, 5,   29,  0,   0,   787, 792, 5,   43,  0,   0,
      788, 790, 3,   58,  29,  0,   789, 788, 1,   0,   0,   0,   789, 790, 1,   0,   0,   0,   790,
      793, 1,   0,   0,   0,   791, 793, 3,   158, 79,  0,   792, 789, 1,   0,   0,   0,   792, 791,
      1,   0,   0,   0,   793, 794, 1,   0,   0,   0,   794, 795, 5,   44,  0,   0,   795, 796, 3,
      104, 52,  0,   796, 157, 1,   0,   0,   0,   797, 799, 3,   110, 55,  0,   798, 797, 1,   0,
      0,   0,   798, 799, 1,   0,   0,   0,   799, 800, 1,   0,   0,   0,   800, 802, 3,   164, 82,
      0,   801, 803, 3,   58,  29,  0,   802, 801, 1,   0,   0,   0,   802, 803, 1,   0,   0,   0,
      803, 804, 1,   0,   0,   0,   804, 806, 3,   164, 82,  0,   805, 807, 3,   110, 55,  0,   806,
      805, 1,   0,   0,   0,   806, 807, 1,   0,   0,   0,   807, 159, 1,   0,   0,   0,   808, 809,
      5,   28,  0,   0,   809, 810, 5,   43,  0,   0,   810, 811, 3,   58,  29,  0,   811, 812, 5,
      44,  0,   0,   812, 813, 3,   104, 52,  0,   813, 161, 1,   0,   0,   0,   814, 815, 5,   31,
      0,   0,   815, 816, 3,   104, 52,  0,   816, 817, 5,   28,  0,   0,   817, 818, 5,   43,  0,
      0,   818, 819, 3,   58,  29,  0,   819, 820, 5,   44,  0,   0,   820, 163, 1,   0,   0,   0,
      821, 822, 5,   80,  0,   0,   822, 165, 1,   0,   0,   0,   93,  170, 176, 191, 198, 204, 214,
      218, 222, 232, 236, 245, 262, 267, 288, 301, 305, 311, 315, 322, 326, 334, 338, 340, 350, 354,
      357, 364, 378, 380, 383, 386, 388, 397, 400, 408, 425, 427, 434, 443, 447, 454, 463, 471, 478,
      486, 492, 515, 520, 522, 531, 537, 543, 547, 556, 565, 568, 571, 578, 589, 593, 598, 605, 621,
      627, 639, 652, 656, 660, 664, 681, 688, 690, 694, 699, 702, 706, 708, 715, 723, 728, 740, 747,
      754, 765, 770, 774, 779, 783, 789, 792, 798, 802, 806};
  staticData->serializedATN = antlr4::atn::SerializedATNView(
      serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) {
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  autotenv1parserParserStaticData = staticData.release();
}

}  // namespace

AutoTenV1Parser::AutoTenV1Parser(TokenStream* input)
    : AutoTenV1Parser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

AutoTenV1Parser::AutoTenV1Parser(TokenStream* input,
                                 const antlr4::atn::ParserATNSimulatorOptions& options)
    : Parser(input) {
  AutoTenV1Parser::initialize();
  _interpreter = new atn::ParserATNSimulator(
      this, *autotenv1parserParserStaticData->atn, autotenv1parserParserStaticData->decisionToDFA,
      autotenv1parserParserStaticData->sharedContextCache, options);
}

AutoTenV1Parser::~AutoTenV1Parser() { delete _interpreter; }

const atn::ATN& AutoTenV1Parser::getATN() const { return *autotenv1parserParserStaticData->atn; }

std::string AutoTenV1Parser::getGrammarFileName() const { return "AutoTenV1Parser.g4"; }

const std::vector<std::string>& AutoTenV1Parser::getRuleNames() const {
  return autotenv1parserParserStaticData->ruleNames;
}

const dfa::Vocabulary& AutoTenV1Parser::getVocabulary() const {
  return autotenv1parserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView AutoTenV1Parser::getSerializedATN() const {
  return autotenv1parserParserStaticData->serializedATN;
}

//----------------- SourceFileContext
//------------------------------------------------------------------

AutoTenV1Parser::SourceFileContext::SourceFileContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::PackageClauseContext* AutoTenV1Parser::SourceFileContext::packageClause() {
  return getRuleContext<AutoTenV1Parser::PackageClauseContext>(0);
}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::SourceFileContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::SourceFileContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

tree::TerminalNode* AutoTenV1Parser::SourceFileContext::EOF() {
  return getToken(AutoTenV1Parser::EOF, 0);
}

std::vector<AutoTenV1Parser::FunctionDeclContext*>
AutoTenV1Parser::SourceFileContext::functionDecl() {
  return getRuleContexts<AutoTenV1Parser::FunctionDeclContext>();
}

AutoTenV1Parser::FunctionDeclContext* AutoTenV1Parser::SourceFileContext::functionDecl(size_t i) {
  return getRuleContext<AutoTenV1Parser::FunctionDeclContext>(i);
}

std::vector<AutoTenV1Parser::DeclarationContext*>
AutoTenV1Parser::SourceFileContext::declaration() {
  return getRuleContexts<AutoTenV1Parser::DeclarationContext>();
}

AutoTenV1Parser::DeclarationContext* AutoTenV1Parser::SourceFileContext::declaration(size_t i) {
  return getRuleContext<AutoTenV1Parser::DeclarationContext>(i);
}

size_t AutoTenV1Parser::SourceFileContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleSourceFile;
}

void AutoTenV1Parser::SourceFileContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSourceFile(this);
}

void AutoTenV1Parser::SourceFileContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSourceFile(this);
}

std::any AutoTenV1Parser::SourceFileContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSourceFile(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::SourceFileContext* AutoTenV1Parser::sourceFile() {
  SourceFileContext* _localctx = _tracker.createInstance<SourceFileContext>(_ctx, getState());
  enterRule(_localctx, 0, AutoTenV1Parser::RuleSourceFile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(166);
    packageClause();
    setState(167);
    eos();
    setState(176);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 309237907456) != 0)) {
      setState(170);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case AutoTenV1Parser::Function: {
          setState(168);
          functionDecl();
          break;
        }

        case AutoTenV1Parser::Var:
        case AutoTenV1Parser::Type: {
          setState(169);
          declaration();
          break;
        }

        default: throw NoViableAltException(this);
      }
      setState(172);
      eos();
      setState(178);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(179);
    match(AutoTenV1Parser::EOF);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PackageClauseContext
//------------------------------------------------------------------

AutoTenV1Parser::PackageClauseContext::PackageClauseContext(ParserRuleContext* parent,
                                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::PackageClauseContext::At() {
  return getToken(AutoTenV1Parser::At, 0);
}

tree::TerminalNode* AutoTenV1Parser::PackageClauseContext::Package() {
  return getToken(AutoTenV1Parser::Package, 0);
}

tree::TerminalNode* AutoTenV1Parser::PackageClauseContext::StringLiteral() {
  return getToken(AutoTenV1Parser::StringLiteral, 0);
}

size_t AutoTenV1Parser::PackageClauseContext::getRuleIndex() const {
  return AutoTenV1Parser::RulePackageClause;
}

void AutoTenV1Parser::PackageClauseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPackageClause(this);
}

void AutoTenV1Parser::PackageClauseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPackageClause(this);
}

std::any AutoTenV1Parser::PackageClauseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitPackageClause(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::PackageClauseContext* AutoTenV1Parser::packageClause() {
  PackageClauseContext* _localctx = _tracker.createInstance<PackageClauseContext>(_ctx, getState());
  enterRule(_localctx, 2, AutoTenV1Parser::RulePackageClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(181);
    match(AutoTenV1Parser::At);
    setState(182);
    match(AutoTenV1Parser::Package);
    setState(183);
    antlrcpp::downCast<PackageClauseContext*>(_localctx)->packageName =
        match(AutoTenV1Parser::StringLiteral);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompileFlagsContext
//------------------------------------------------------------------

AutoTenV1Parser::CompileFlagsContext::CompileFlagsContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::At() {
  return getToken(AutoTenV1Parser::At, 0);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::CompileFlagsContext::Identifier() {
  return getTokens(AutoTenV1Parser::Identifier);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::Identifier(size_t i) {
  return getToken(AutoTenV1Parser::Identifier, i);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::Semi() {
  return getToken(AutoTenV1Parser::Semi, 0);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::Assign() {
  return getToken(AutoTenV1Parser::Assign, 0);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::True_() {
  return getToken(AutoTenV1Parser::True_, 0);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::False_() {
  return getToken(AutoTenV1Parser::False_, 0);
}

tree::TerminalNode* AutoTenV1Parser::CompileFlagsContext::StringLiteral() {
  return getToken(AutoTenV1Parser::StringLiteral, 0);
}

size_t AutoTenV1Parser::CompileFlagsContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleCompileFlags;
}

void AutoTenV1Parser::CompileFlagsContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCompileFlags(this);
}

void AutoTenV1Parser::CompileFlagsContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCompileFlags(this);
}

std::any AutoTenV1Parser::CompileFlagsContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitCompileFlags(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::CompileFlagsContext* AutoTenV1Parser::compileFlags() {
  CompileFlagsContext* _localctx = _tracker.createInstance<CompileFlagsContext>(_ctx, getState());
  enterRule(_localctx, 4, AutoTenV1Parser::RuleCompileFlags);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(185);
    match(AutoTenV1Parser::At);
    setState(186);
    match(AutoTenV1Parser::Identifier);
    setState(191);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(187);
        matchWildcard();
        setState(188);
        match(AutoTenV1Parser::Identifier);
      }
      setState(193);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx);
    }
    setState(198);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Assign: {
        setState(194);
        match(AutoTenV1Parser::Assign);
        setState(195);
        match(AutoTenV1Parser::True_);
        break;
      }

      case AutoTenV1Parser::False_: {
        setState(196);
        match(AutoTenV1Parser::False_);
        break;
      }

      case AutoTenV1Parser::StringLiteral: {
        setState(197);
        match(AutoTenV1Parser::StringLiteral);
        break;
      }

      case AutoTenV1Parser::Semi: {
        break;
      }

      default: break;
    }
    setState(200);
    match(AutoTenV1Parser::Semi);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext
//------------------------------------------------------------------

AutoTenV1Parser::DeclarationContext::DeclarationContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::TypeDeclContext* AutoTenV1Parser::DeclarationContext::typeDecl() {
  return getRuleContext<AutoTenV1Parser::TypeDeclContext>(0);
}

AutoTenV1Parser::VarDeclContext* AutoTenV1Parser::DeclarationContext::varDecl() {
  return getRuleContext<AutoTenV1Parser::VarDeclContext>(0);
}

size_t AutoTenV1Parser::DeclarationContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleDeclaration;
}

void AutoTenV1Parser::DeclarationContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDeclaration(this);
}

void AutoTenV1Parser::DeclarationContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDeclaration(this);
}

std::any AutoTenV1Parser::DeclarationContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::DeclarationContext* AutoTenV1Parser::declaration() {
  DeclarationContext* _localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 6, AutoTenV1Parser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(204);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Type: {
        enterOuterAlt(_localctx, 1);
        setState(202);
        typeDecl();
        break;
      }

      case AutoTenV1Parser::Var: {
        enterOuterAlt(_localctx, 2);
        setState(203);
        varDecl();
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeDeclContext::TypeDeclContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::TypeDeclContext::Type() {
  return getToken(AutoTenV1Parser::Type, 0);
}

std::vector<AutoTenV1Parser::TypeSpecContext*> AutoTenV1Parser::TypeDeclContext::typeSpec() {
  return getRuleContexts<AutoTenV1Parser::TypeSpecContext>();
}

AutoTenV1Parser::TypeSpecContext* AutoTenV1Parser::TypeDeclContext::typeSpec(size_t i) {
  return getRuleContext<AutoTenV1Parser::TypeSpecContext>(i);
}

tree::TerminalNode* AutoTenV1Parser::TypeDeclContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeDeclContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::TypeDeclContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::TypeDeclContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

size_t AutoTenV1Parser::TypeDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeDecl;
}

void AutoTenV1Parser::TypeDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeDecl(this);
}

void AutoTenV1Parser::TypeDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeDecl(this);
}

std::any AutoTenV1Parser::TypeDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeDeclContext* AutoTenV1Parser::typeDecl() {
  TypeDeclContext* _localctx = _tracker.createInstance<TypeDeclContext>(_ctx, getState());
  enterRule(_localctx, 8, AutoTenV1Parser::RuleTypeDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(206);
    match(AutoTenV1Parser::Type);
    setState(218);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Identifier: {
        setState(207);
        typeSpec();
        break;
      }

      case AutoTenV1Parser::LeftParen: {
        setState(208);
        match(AutoTenV1Parser::LeftParen);
        setState(214);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == AutoTenV1Parser::Identifier) {
          setState(209);
          typeSpec();
          setState(210);
          eos();
          setState(216);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(217);
        match(AutoTenV1Parser::RightParen);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSpecContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeSpecContext::TypeSpecContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::TypeSpecContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::TypeSpecContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSpecContext::Assign() {
  return getToken(AutoTenV1Parser::Assign, 0);
}

size_t AutoTenV1Parser::TypeSpecContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeSpec;
}

void AutoTenV1Parser::TypeSpecContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeSpec(this);
}

void AutoTenV1Parser::TypeSpecContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeSpec(this);
}

std::any AutoTenV1Parser::TypeSpecContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeSpec(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeSpecContext* AutoTenV1Parser::typeSpec() {
  TypeSpecContext* _localctx = _tracker.createInstance<TypeSpecContext>(_ctx, getState());
  enterRule(_localctx, 10, AutoTenV1Parser::RuleTypeSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(220);
    match(AutoTenV1Parser::Identifier);
    setState(222);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Assign) {
      setState(221);
      match(AutoTenV1Parser::Assign);
    }
    setState(224);
    type_();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_Context ------------------------------------------------------------------

AutoTenV1Parser::Type_Context::Type_Context(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::TypeNameContext* AutoTenV1Parser::Type_Context::typeName() {
  return getRuleContext<AutoTenV1Parser::TypeNameContext>(0);
}

AutoTenV1Parser::TypeLitContext* AutoTenV1Parser::Type_Context::typeLit() {
  return getRuleContext<AutoTenV1Parser::TypeLitContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::Type_Context::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::Type_Context::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

tree::TerminalNode* AutoTenV1Parser::Type_Context::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

size_t AutoTenV1Parser::Type_Context::getRuleIndex() const { return AutoTenV1Parser::RuleType_; }

void AutoTenV1Parser::Type_Context::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterType_(this);
}

void AutoTenV1Parser::Type_Context::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitType_(this);
}

std::any AutoTenV1Parser::Type_Context::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitType_(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::type_() {
  Type_Context* _localctx = _tracker.createInstance<Type_Context>(_ctx, getState());
  enterRule(_localctx, 12, AutoTenV1Parser::RuleType_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(232);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(226);
        typeName();
        break;
      }

      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Map: {
        enterOuterAlt(_localctx, 2);
        setState(227);
        typeLit();
        break;
      }

      case AutoTenV1Parser::LeftParen: {
        enterOuterAlt(_localctx, 3);
        setState(228);
        match(AutoTenV1Parser::LeftParen);
        setState(229);
        type_();
        setState(230);
        match(AutoTenV1Parser::RightParen);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeNameContext::TypeNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::QualifiedIdentContext* AutoTenV1Parser::TypeNameContext::qualifiedIdent() {
  return getRuleContext<AutoTenV1Parser::QualifiedIdentContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeNameContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::TypeNameContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeName;
}

void AutoTenV1Parser::TypeNameContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeName(this);
}

void AutoTenV1Parser::TypeNameContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeName(this);
}

std::any AutoTenV1Parser::TypeNameContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeName(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeNameContext* AutoTenV1Parser::typeName() {
  TypeNameContext* _localctx = _tracker.createInstance<TypeNameContext>(_ctx, getState());
  enterRule(_localctx, 14, AutoTenV1Parser::RuleTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(236);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(234);
        qualifiedIdent();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(235);
        match(AutoTenV1Parser::Identifier);
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLitContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeLitContext::TypeLitContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ArrayTypeContext* AutoTenV1Parser::TypeLitContext::arrayType() {
  return getRuleContext<AutoTenV1Parser::ArrayTypeContext>(0);
}

AutoTenV1Parser::StructTypeContext* AutoTenV1Parser::TypeLitContext::structType() {
  return getRuleContext<AutoTenV1Parser::StructTypeContext>(0);
}

AutoTenV1Parser::PointerTypeContext* AutoTenV1Parser::TypeLitContext::pointerType() {
  return getRuleContext<AutoTenV1Parser::PointerTypeContext>(0);
}

AutoTenV1Parser::FunctionTypeContext* AutoTenV1Parser::TypeLitContext::functionType() {
  return getRuleContext<AutoTenV1Parser::FunctionTypeContext>(0);
}

AutoTenV1Parser::ImplTypeContext* AutoTenV1Parser::TypeLitContext::implType() {
  return getRuleContext<AutoTenV1Parser::ImplTypeContext>(0);
}

AutoTenV1Parser::SliceTypeContext* AutoTenV1Parser::TypeLitContext::sliceType() {
  return getRuleContext<AutoTenV1Parser::SliceTypeContext>(0);
}

AutoTenV1Parser::MapTypeContext* AutoTenV1Parser::TypeLitContext::mapType() {
  return getRuleContext<AutoTenV1Parser::MapTypeContext>(0);
}

size_t AutoTenV1Parser::TypeLitContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeLit;
}

void AutoTenV1Parser::TypeLitContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeLit(this);
}

void AutoTenV1Parser::TypeLitContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeLit(this);
}

std::any AutoTenV1Parser::TypeLitContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeLit(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeLitContext* AutoTenV1Parser::typeLit() {
  TypeLitContext* _localctx = _tracker.createInstance<TypeLitContext>(_ctx, getState());
  enterRule(_localctx, 16, AutoTenV1Parser::RuleTypeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(245);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(238);
        arrayType();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(239);
        structType();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(240);
        pointerType();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(241);
        functionType();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(242);
        implType();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(243);
        sliceType();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(244);
        mapType();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ArrayTypeContext::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

AutoTenV1Parser::ArrayLengthContext* AutoTenV1Parser::ArrayTypeContext::arrayLength() {
  return getRuleContext<AutoTenV1Parser::ArrayLengthContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ArrayTypeContext::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

AutoTenV1Parser::ElementTypeContext* AutoTenV1Parser::ArrayTypeContext::elementType() {
  return getRuleContext<AutoTenV1Parser::ElementTypeContext>(0);
}

size_t AutoTenV1Parser::ArrayTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleArrayType;
}

void AutoTenV1Parser::ArrayTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterArrayType(this);
}

void AutoTenV1Parser::ArrayTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitArrayType(this);
}

std::any AutoTenV1Parser::ArrayTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitArrayType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ArrayTypeContext* AutoTenV1Parser::arrayType() {
  ArrayTypeContext* _localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 18, AutoTenV1Parser::RuleArrayType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(247);
    match(AutoTenV1Parser::LeftBracket);
    setState(248);
    arrayLength();
    setState(249);
    match(AutoTenV1Parser::RightBracket);
    setState(250);
    elementType();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayLengthContext
//------------------------------------------------------------------

AutoTenV1Parser::ArrayLengthContext::ArrayLengthContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ArrayLengthContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

size_t AutoTenV1Parser::ArrayLengthContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleArrayLength;
}

void AutoTenV1Parser::ArrayLengthContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterArrayLength(this);
}

void AutoTenV1Parser::ArrayLengthContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitArrayLength(this);
}

std::any AutoTenV1Parser::ArrayLengthContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitArrayLength(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ArrayLengthContext* AutoTenV1Parser::arrayLength() {
  ArrayLengthContext* _localctx = _tracker.createInstance<ArrayLengthContext>(_ctx, getState());
  enterRule(_localctx, 20, AutoTenV1Parser::RuleArrayLength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(252);
    expression(0);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::ElementTypeContext::ElementTypeContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::ElementTypeContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

size_t AutoTenV1Parser::ElementTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleElementType;
}

void AutoTenV1Parser::ElementTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterElementType(this);
}

void AutoTenV1Parser::ElementTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitElementType(this);
}

std::any AutoTenV1Parser::ElementTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitElementType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ElementTypeContext* AutoTenV1Parser::elementType() {
  ElementTypeContext* _localctx = _tracker.createInstance<ElementTypeContext>(_ctx, getState());
  enterRule(_localctx, 22, AutoTenV1Parser::RuleElementType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(254);
    type_();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::PointerTypeContext::PointerTypeContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::PointerTypeContext::Star() {
  return getToken(AutoTenV1Parser::Star, 0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::PointerTypeContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

size_t AutoTenV1Parser::PointerTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RulePointerType;
}

void AutoTenV1Parser::PointerTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPointerType(this);
}

void AutoTenV1Parser::PointerTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPointerType(this);
}

std::any AutoTenV1Parser::PointerTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitPointerType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::PointerTypeContext* AutoTenV1Parser::pointerType() {
  PointerTypeContext* _localctx = _tracker.createInstance<PointerTypeContext>(_ctx, getState());
  enterRule(_localctx, 24, AutoTenV1Parser::RulePointerType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(256);
    match(AutoTenV1Parser::Star);
    setState(257);
    type_();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImplTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::ImplTypeContext::ImplTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ImplTypeContext::Impl() {
  return getToken(AutoTenV1Parser::Impl, 0);
}

tree::TerminalNode* AutoTenV1Parser::ImplTypeContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::ImplTypeContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

std::vector<AutoTenV1Parser::FunctionLitContext*> AutoTenV1Parser::ImplTypeContext::functionLit() {
  return getRuleContexts<AutoTenV1Parser::FunctionLitContext>();
}

AutoTenV1Parser::FunctionLitContext* AutoTenV1Parser::ImplTypeContext::functionLit(size_t i) {
  return getRuleContext<AutoTenV1Parser::FunctionLitContext>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::ImplTypeContext::Public() {
  return getTokens(AutoTenV1Parser::Public);
}

tree::TerminalNode* AutoTenV1Parser::ImplTypeContext::Public(size_t i) {
  return getToken(AutoTenV1Parser::Public, i);
}

size_t AutoTenV1Parser::ImplTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleImplType;
}

void AutoTenV1Parser::ImplTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterImplType(this);
}

void AutoTenV1Parser::ImplTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitImplType(this);
}

std::any AutoTenV1Parser::ImplTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitImplType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ImplTypeContext* AutoTenV1Parser::implType() {
  ImplTypeContext* _localctx = _tracker.createInstance<ImplTypeContext>(_ctx, getState());
  enterRule(_localctx, 26, AutoTenV1Parser::RuleImplType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(259);
    match(AutoTenV1Parser::Impl);
    setState(260);
    match(AutoTenV1Parser::LeftBrace);
    setState(267);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 35) & ~0x3fULL) == 0) && ((1ULL << (_la - 35)) & 17592186044481) != 0)) {
      setState(262);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Public) {
        setState(261);
        match(AutoTenV1Parser::Public);
      }
      setState(264);
      functionLit();
      setState(269);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(270);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::SliceTypeContext::SliceTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::SliceTypeContext::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

tree::TerminalNode* AutoTenV1Parser::SliceTypeContext::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

AutoTenV1Parser::ElementTypeContext* AutoTenV1Parser::SliceTypeContext::elementType() {
  return getRuleContext<AutoTenV1Parser::ElementTypeContext>(0);
}

size_t AutoTenV1Parser::SliceTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleSliceType;
}

void AutoTenV1Parser::SliceTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSliceType(this);
}

void AutoTenV1Parser::SliceTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSliceType(this);
}

std::any AutoTenV1Parser::SliceTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSliceType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::SliceTypeContext* AutoTenV1Parser::sliceType() {
  SliceTypeContext* _localctx = _tracker.createInstance<SliceTypeContext>(_ctx, getState());
  enterRule(_localctx, 28, AutoTenV1Parser::RuleSliceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(272);
    match(AutoTenV1Parser::LeftBracket);
    setState(273);
    match(AutoTenV1Parser::RightBracket);
    setState(274);
    elementType();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MapTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::MapTypeContext::MapTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::MapTypeContext::Map() {
  return getToken(AutoTenV1Parser::Map, 0);
}

tree::TerminalNode* AutoTenV1Parser::MapTypeContext::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::MapTypeContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

tree::TerminalNode* AutoTenV1Parser::MapTypeContext::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

AutoTenV1Parser::ElementTypeContext* AutoTenV1Parser::MapTypeContext::elementType() {
  return getRuleContext<AutoTenV1Parser::ElementTypeContext>(0);
}

size_t AutoTenV1Parser::MapTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleMapType;
}

void AutoTenV1Parser::MapTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMapType(this);
}

void AutoTenV1Parser::MapTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMapType(this);
}

std::any AutoTenV1Parser::MapTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitMapType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::MapTypeContext* AutoTenV1Parser::mapType() {
  MapTypeContext* _localctx = _tracker.createInstance<MapTypeContext>(_ctx, getState());
  enterRule(_localctx, 30, AutoTenV1Parser::RuleMapType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(276);
    match(AutoTenV1Parser::Map);
    setState(277);
    match(AutoTenV1Parser::LeftBracket);
    setState(278);
    type_();
    setState(279);
    match(AutoTenV1Parser::RightBracket);
    setState(280);
    elementType();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodSpecContext
//------------------------------------------------------------------

AutoTenV1Parser::MethodSpecContext::MethodSpecContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::MethodSpecContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

AutoTenV1Parser::ParametersContext* AutoTenV1Parser::MethodSpecContext::parameters() {
  return getRuleContext<AutoTenV1Parser::ParametersContext>(0);
}

AutoTenV1Parser::ResultContext* AutoTenV1Parser::MethodSpecContext::result() {
  return getRuleContext<AutoTenV1Parser::ResultContext>(0);
}

size_t AutoTenV1Parser::MethodSpecContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleMethodSpec;
}

void AutoTenV1Parser::MethodSpecContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMethodSpec(this);
}

void AutoTenV1Parser::MethodSpecContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMethodSpec(this);
}

std::any AutoTenV1Parser::MethodSpecContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitMethodSpec(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::MethodSpecContext* AutoTenV1Parser::methodSpec() {
  MethodSpecContext* _localctx = _tracker.createInstance<MethodSpecContext>(_ctx, getState());
  enterRule(_localctx, 32, AutoTenV1Parser::RuleMethodSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(288);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(282);
        match(AutoTenV1Parser::Identifier);
        setState(283);
        parameters();
        setState(284);
        result();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(286);
        match(AutoTenV1Parser::Identifier);
        setState(287);
        parameters();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::FunctionTypeContext::FunctionTypeContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::FunctionTypeContext::Function() {
  return getToken(AutoTenV1Parser::Function, 0);
}

AutoTenV1Parser::SignatureContext* AutoTenV1Parser::FunctionTypeContext::signature() {
  return getRuleContext<AutoTenV1Parser::SignatureContext>(0);
}

size_t AutoTenV1Parser::FunctionTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleFunctionType;
}

void AutoTenV1Parser::FunctionTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFunctionType(this);
}

void AutoTenV1Parser::FunctionTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFunctionType(this);
}

std::any AutoTenV1Parser::FunctionTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitFunctionType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::FunctionTypeContext* AutoTenV1Parser::functionType() {
  FunctionTypeContext* _localctx = _tracker.createInstance<FunctionTypeContext>(_ctx, getState());
  enterRule(_localctx, 34, AutoTenV1Parser::RuleFunctionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(290);
    match(AutoTenV1Parser::Function);
    setState(291);
    signature();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::VarDeclContext::VarDeclContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::VarDeclContext::Var() {
  return getToken(AutoTenV1Parser::Var, 0);
}

std::vector<AutoTenV1Parser::VarSpecContext*> AutoTenV1Parser::VarDeclContext::varSpec() {
  return getRuleContexts<AutoTenV1Parser::VarSpecContext>();
}

AutoTenV1Parser::VarSpecContext* AutoTenV1Parser::VarDeclContext::varSpec(size_t i) {
  return getRuleContext<AutoTenV1Parser::VarSpecContext>(i);
}

tree::TerminalNode* AutoTenV1Parser::VarDeclContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::VarDeclContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::VarDeclContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::VarDeclContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

size_t AutoTenV1Parser::VarDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleVarDecl;
}

void AutoTenV1Parser::VarDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVarDecl(this);
}

void AutoTenV1Parser::VarDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVarDecl(this);
}

std::any AutoTenV1Parser::VarDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitVarDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::VarDeclContext* AutoTenV1Parser::varDecl() {
  VarDeclContext* _localctx = _tracker.createInstance<VarDeclContext>(_ctx, getState());
  enterRule(_localctx, 36, AutoTenV1Parser::RuleVarDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    match(AutoTenV1Parser::Var);
    setState(305);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Identifier: {
        setState(294);
        varSpec();
        break;
      }

      case AutoTenV1Parser::LeftParen: {
        setState(295);
        match(AutoTenV1Parser::LeftParen);
        setState(301);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == AutoTenV1Parser::Identifier) {
          setState(296);
          varSpec();
          setState(297);
          eos();
          setState(303);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(304);
        match(AutoTenV1Parser::RightParen);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarSpecContext
//------------------------------------------------------------------

AutoTenV1Parser::VarSpecContext::VarSpecContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::IdentifierListContext* AutoTenV1Parser::VarSpecContext::identifierList() {
  return getRuleContext<AutoTenV1Parser::IdentifierListContext>(0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::VarSpecContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

tree::TerminalNode* AutoTenV1Parser::VarSpecContext::Assign() {
  return getToken(AutoTenV1Parser::Assign, 0);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::VarSpecContext::expressionList() {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(0);
}

size_t AutoTenV1Parser::VarSpecContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleVarSpec;
}

void AutoTenV1Parser::VarSpecContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterVarSpec(this);
}

void AutoTenV1Parser::VarSpecContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitVarSpec(this);
}

std::any AutoTenV1Parser::VarSpecContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitVarSpec(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::VarSpecContext* AutoTenV1Parser::varSpec() {
  VarSpecContext* _localctx = _tracker.createInstance<VarSpecContext>(_ctx, getState());
  enterRule(_localctx, 38, AutoTenV1Parser::RuleVarSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(307);
    identifierList();
    setState(315);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftParen:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Map:
      case AutoTenV1Parser::Identifier: {
        setState(308);
        type_();
        setState(311);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == AutoTenV1Parser::Assign) {
          setState(309);
          match(AutoTenV1Parser::Assign);
          setState(310);
          expressionList();
        }
        break;
      }

      case AutoTenV1Parser::Assign: {
        setState(313);
        match(AutoTenV1Parser::Assign);
        setState(314);
        expressionList();
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignatureContext
//------------------------------------------------------------------

AutoTenV1Parser::SignatureContext::SignatureContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ParametersContext* AutoTenV1Parser::SignatureContext::parameters() {
  return getRuleContext<AutoTenV1Parser::ParametersContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::SignatureContext::ArrowReturnType() {
  return getToken(AutoTenV1Parser::ArrowReturnType, 0);
}

AutoTenV1Parser::ResultContext* AutoTenV1Parser::SignatureContext::result() {
  return getRuleContext<AutoTenV1Parser::ResultContext>(0);
}

size_t AutoTenV1Parser::SignatureContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleSignature;
}

void AutoTenV1Parser::SignatureContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSignature(this);
}

void AutoTenV1Parser::SignatureContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSignature(this);
}

std::any AutoTenV1Parser::SignatureContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSignature(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::SignatureContext* AutoTenV1Parser::signature() {
  SignatureContext* _localctx = _tracker.createInstance<SignatureContext>(_ctx, getState());
  enterRule(_localctx, 40, AutoTenV1Parser::RuleSignature);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(322);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(317);
        parameters();
        setState(318);
        match(AutoTenV1Parser::ArrowReturnType);
        setState(319);
        result();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(321);
        parameters();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultContext ------------------------------------------------------------------

AutoTenV1Parser::ResultContext::ResultContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ParametersContext* AutoTenV1Parser::ResultContext::parameters() {
  return getRuleContext<AutoTenV1Parser::ParametersContext>(0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::ResultContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

size_t AutoTenV1Parser::ResultContext::getRuleIndex() const { return AutoTenV1Parser::RuleResult; }

void AutoTenV1Parser::ResultContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterResult(this);
}

void AutoTenV1Parser::ResultContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitResult(this);
}

std::any AutoTenV1Parser::ResultContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitResult(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ResultContext* AutoTenV1Parser::result() {
  ResultContext* _localctx = _tracker.createInstance<ResultContext>(_ctx, getState());
  enterRule(_localctx, 42, AutoTenV1Parser::RuleResult);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(326);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(324);
        parameters();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(325);
        type_();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext
//------------------------------------------------------------------

AutoTenV1Parser::ParametersContext::ParametersContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ParametersContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ParametersContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

std::vector<AutoTenV1Parser::ParameterDeclContext*>
AutoTenV1Parser::ParametersContext::parameterDecl() {
  return getRuleContexts<AutoTenV1Parser::ParameterDeclContext>();
}

AutoTenV1Parser::ParameterDeclContext* AutoTenV1Parser::ParametersContext::parameterDecl(size_t i) {
  return getRuleContext<AutoTenV1Parser::ParameterDeclContext>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::ParametersContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::ParametersContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::ParametersContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleParameters;
}

void AutoTenV1Parser::ParametersContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterParameters(this);
}

void AutoTenV1Parser::ParametersContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitParameters(this);
}

std::any AutoTenV1Parser::ParametersContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitParameters(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ParametersContext* AutoTenV1Parser::parameters() {
  ParametersContext* _localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 44, AutoTenV1Parser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(328);
    match(AutoTenV1Parser::LeftParen);
    setState(340);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 35) & ~0x3fULL) == 0) && ((1ULL << (_la - 35)) & 492581209310501) != 0)) {
      setState(329);
      parameterDecl();
      setState(334);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(330);
          match(AutoTenV1Parser::Comma);
          setState(331);
          parameterDecl();
        }
        setState(336);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
      }
      setState(338);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Comma) {
        setState(337);
        match(AutoTenV1Parser::Comma);
      }
    }
    setState(342);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

AutoTenV1Parser::IndexContext::IndexContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::IndexContext::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::IndexContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::IndexContext::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

size_t AutoTenV1Parser::IndexContext::getRuleIndex() const { return AutoTenV1Parser::RuleIndex; }

void AutoTenV1Parser::IndexContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIndex(this);
}

void AutoTenV1Parser::IndexContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIndex(this);
}

std::any AutoTenV1Parser::IndexContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::IndexContext* AutoTenV1Parser::index() {
  IndexContext* _localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 46, AutoTenV1Parser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(344);
    match(AutoTenV1Parser::LeftBracket);
    setState(345);
    expression(0);
    setState(346);
    match(AutoTenV1Parser::RightBracket);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Slice_Context ------------------------------------------------------------------

AutoTenV1Parser::Slice_Context::Slice_Context(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::Slice_Context::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

tree::TerminalNode* AutoTenV1Parser::Slice_Context::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::Slice_Context::Colon() {
  return getTokens(AutoTenV1Parser::Colon);
}

tree::TerminalNode* AutoTenV1Parser::Slice_Context::Colon(size_t i) {
  return getToken(AutoTenV1Parser::Colon, i);
}

std::vector<AutoTenV1Parser::ExpressionContext*> AutoTenV1Parser::Slice_Context::expression() {
  return getRuleContexts<AutoTenV1Parser::ExpressionContext>();
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::Slice_Context::expression(size_t i) {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(i);
}

size_t AutoTenV1Parser::Slice_Context::getRuleIndex() const { return AutoTenV1Parser::RuleSlice_; }

void AutoTenV1Parser::Slice_Context::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSlice_(this);
}

void AutoTenV1Parser::Slice_Context::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSlice_(this);
}

std::any AutoTenV1Parser::Slice_Context::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSlice_(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::Slice_Context* AutoTenV1Parser::slice_() {
  Slice_Context* _localctx = _tracker.createInstance<Slice_Context>(_ctx, getState());
  enterRule(_localctx, 48, AutoTenV1Parser::RuleSlice_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(348);
    match(AutoTenV1Parser::LeftBracket);
    setState(364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
      case 1: {
        setState(350);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(349);
          expression(0);
        }
        setState(352);
        match(AutoTenV1Parser::Colon);
        setState(354);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(353);
          expression(0);
        }
        break;
      }

      case 2: {
        setState(357);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(356);
          expression(0);
        }
        setState(359);
        match(AutoTenV1Parser::Colon);
        setState(360);
        expression(0);
        setState(361);
        match(AutoTenV1Parser::Colon);
        setState(362);
        expression(0);
        break;
      }

      default: break;
    }
    setState(366);
    match(AutoTenV1Parser::RightBracket);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAssertionContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeAssertionContext::TypeAssertionContext(ParserRuleContext* parent,
                                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::TypeAssertionContext::Dot() {
  return getToken(AutoTenV1Parser::Dot, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeAssertionContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::TypeAssertionContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeAssertionContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

size_t AutoTenV1Parser::TypeAssertionContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeAssertion;
}

void AutoTenV1Parser::TypeAssertionContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeAssertion(this);
}

void AutoTenV1Parser::TypeAssertionContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeAssertion(this);
}

std::any AutoTenV1Parser::TypeAssertionContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeAssertion(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeAssertionContext* AutoTenV1Parser::typeAssertion() {
  TypeAssertionContext* _localctx = _tracker.createInstance<TypeAssertionContext>(_ctx, getState());
  enterRule(_localctx, 50, AutoTenV1Parser::RuleTypeAssertion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    match(AutoTenV1Parser::Dot);
    setState(369);
    match(AutoTenV1Parser::LeftParen);
    setState(370);
    type_();
    setState(371);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext
//------------------------------------------------------------------

AutoTenV1Parser::ArgumentsContext::ArgumentsContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ArgumentsContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ArgumentsContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::ArgumentsContext::expressionList() {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(0);
}

AutoTenV1Parser::NonNamedTypeContext* AutoTenV1Parser::ArgumentsContext::nonNamedType() {
  return getRuleContext<AutoTenV1Parser::NonNamedTypeContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ArgumentsContext::Ellipsis() {
  return getToken(AutoTenV1Parser::Ellipsis, 0);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::ArgumentsContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::ArgumentsContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::ArgumentsContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleArguments;
}

void AutoTenV1Parser::ArgumentsContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterArguments(this);
}

void AutoTenV1Parser::ArgumentsContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitArguments(this);
}

std::any AutoTenV1Parser::ArgumentsContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ArgumentsContext* AutoTenV1Parser::arguments() {
  ArgumentsContext* _localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 52, AutoTenV1Parser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(373);
    match(AutoTenV1Parser::LeftParen);
    setState(388);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(380);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
        case 1: {
          setState(374);
          expressionList();
          break;
        }

        case 2: {
          setState(375);
          nonNamedType();
          setState(378);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
            case 1: {
              setState(376);
              match(AutoTenV1Parser::Comma);
              setState(377);
              expressionList();
              break;
            }

            default: break;
          }
          break;
        }

        default: break;
      }
      setState(383);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Ellipsis) {
        setState(382);
        match(AutoTenV1Parser::Ellipsis);
      }
      setState(386);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Comma) {
        setState(385);
        match(AutoTenV1Parser::Comma);
      }
    }
    setState(390);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MethodExprContext
//------------------------------------------------------------------

AutoTenV1Parser::MethodExprContext::MethodExprContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::NonNamedTypeContext* AutoTenV1Parser::MethodExprContext::nonNamedType() {
  return getRuleContext<AutoTenV1Parser::NonNamedTypeContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::MethodExprContext::Dot() {
  return getToken(AutoTenV1Parser::Dot, 0);
}

tree::TerminalNode* AutoTenV1Parser::MethodExprContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::MethodExprContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleMethodExpr;
}

void AutoTenV1Parser::MethodExprContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterMethodExpr(this);
}

void AutoTenV1Parser::MethodExprContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitMethodExpr(this);
}

std::any AutoTenV1Parser::MethodExprContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitMethodExpr(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::MethodExprContext* AutoTenV1Parser::methodExpr() {
  MethodExprContext* _localctx = _tracker.createInstance<MethodExprContext>(_ctx, getState());
  enterRule(_localctx, 54, AutoTenV1Parser::RuleMethodExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(392);
    nonNamedType();
    setState(393);
    match(AutoTenV1Parser::Dot);
    setState(394);
    match(AutoTenV1Parser::Identifier);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::ParameterDeclContext::ParameterDeclContext(ParserRuleContext* parent,
                                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::ParameterDeclContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

AutoTenV1Parser::IdentifierListContext* AutoTenV1Parser::ParameterDeclContext::identifierList() {
  return getRuleContext<AutoTenV1Parser::IdentifierListContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ParameterDeclContext::Ellipsis() {
  return getToken(AutoTenV1Parser::Ellipsis, 0);
}

size_t AutoTenV1Parser::ParameterDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleParameterDecl;
}

void AutoTenV1Parser::ParameterDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterParameterDecl(this);
}

void AutoTenV1Parser::ParameterDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitParameterDecl(this);
}

std::any AutoTenV1Parser::ParameterDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitParameterDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ParameterDeclContext* AutoTenV1Parser::parameterDecl() {
  ParameterDeclContext* _localctx = _tracker.createInstance<ParameterDeclContext>(_ctx, getState());
  enterRule(_localctx, 56, AutoTenV1Parser::RuleParameterDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
      case 1: {
        setState(396);
        identifierList();
        break;
      }

      default: break;
    }
    setState(400);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Ellipsis) {
      setState(399);
      match(AutoTenV1Parser::Ellipsis);
    }
    setState(402);
    type_();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext
//------------------------------------------------------------------

AutoTenV1Parser::ExpressionContext::ExpressionContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::PrimaryExprContext* AutoTenV1Parser::ExpressionContext::primaryExpr() {
  return getRuleContext<AutoTenV1Parser::PrimaryExprContext>(0);
}

std::vector<AutoTenV1Parser::ExpressionContext*> AutoTenV1Parser::ExpressionContext::expression() {
  return getRuleContexts<AutoTenV1Parser::ExpressionContext>();
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ExpressionContext::expression(size_t i) {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(i);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Plus() {
  return getToken(AutoTenV1Parser::Plus, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Minus() {
  return getToken(AutoTenV1Parser::Minus, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Not() {
  return getToken(AutoTenV1Parser::Not, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Caret() {
  return getToken(AutoTenV1Parser::Caret, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Star() {
  return getToken(AutoTenV1Parser::Star, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::And() {
  return getToken(AutoTenV1Parser::And, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Div() {
  return getToken(AutoTenV1Parser::Div, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Mod() {
  return getToken(AutoTenV1Parser::Mod, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::LeftShift() {
  return getToken(AutoTenV1Parser::LeftShift, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::RightShift() {
  return getToken(AutoTenV1Parser::RightShift, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Or() {
  return getToken(AutoTenV1Parser::Or, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Equal() {
  return getToken(AutoTenV1Parser::Equal, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::NotEqual() {
  return getToken(AutoTenV1Parser::NotEqual, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Less() {
  return getToken(AutoTenV1Parser::Less, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::LessEqual() {
  return getToken(AutoTenV1Parser::LessEqual, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::Greater() {
  return getToken(AutoTenV1Parser::Greater, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::GreaterEqual() {
  return getToken(AutoTenV1Parser::GreaterEqual, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::AndAnd() {
  return getToken(AutoTenV1Parser::AndAnd, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionContext::OrOr() {
  return getToken(AutoTenV1Parser::OrOr, 0);
}

size_t AutoTenV1Parser::ExpressionContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExpression;
}

void AutoTenV1Parser::ExpressionContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExpression(this);
}

void AutoTenV1Parser::ExpressionContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExpression(this);
}

std::any AutoTenV1Parser::ExpressionContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::expression() { return expression(0); }

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::expression(int precedence) {
  ParserRuleContext* parentContext = _ctx;
  size_t parentState = getState();
  AutoTenV1Parser::ExpressionContext* _localctx =
      _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  AutoTenV1Parser::ExpressionContext* previousContext = _localctx;
  (void)previousContext;  // Silence compiler, in case the context is not used by generated code.
  size_t startState = 58;
  enterRecursionRule(_localctx, 58, AutoTenV1Parser::RuleExpression, precedence);

  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(408);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
      case 1: {
        setState(405);
        primaryExpr(0);
        break;
      }

      case 2: {
        setState(406);
        antlrcpp::downCast<ExpressionContext*>(_localctx)->unary_op = _input->LT(1);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346214221354106880) != 0))) {
          antlrcpp::downCast<ExpressionContext*>(_localctx)->unary_op =
              _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(407);
        expression(6);
        break;
      }

      default: break;
    }
    _ctx->stop = _input->LT(-1);
    setState(427);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty()) triggerExitRuleEvent();
        previousContext = _localctx;
        setState(425);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
          case 1: {
            _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleExpression);
            setState(410);

            if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(411);
            antlrcpp::downCast<ExpressionContext*>(_localctx)->mul_op = _input->LT(1);
            _la = _input->LA(1);
            if (!(((((_la - 51) & ~0x3fULL) == 0) && ((1ULL << (_la - 51)) & 12311) != 0))) {
              antlrcpp::downCast<ExpressionContext*>(_localctx)->mul_op =
                  _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(412);
            expression(6);
            break;
          }

          case 2: {
            _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleExpression);
            setState(413);

            if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(414);
            antlrcpp::downCast<ExpressionContext*>(_localctx)->add_op = _input->LT(1);
            _la = _input->LA(1);
            if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 91760842407673856) != 0))) {
              antlrcpp::downCast<ExpressionContext*>(_localctx)->add_op =
                  _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(415);
            expression(5);
            break;
          }

          case 3: {
            _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleExpression);
            setState(416);

            if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(417);
            antlrcpp::downCast<ExpressionContext*>(_localctx)->rel_op = _input->LT(1);
            _la = _input->LA(1);
            if (!(((((_la - 61) & ~0x3fULL) == 0) && ((1ULL << (_la - 61)) & 243) != 0))) {
              antlrcpp::downCast<ExpressionContext*>(_localctx)->rel_op =
                  _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(418);
            expression(4);
            break;
          }

          case 4: {
            _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleExpression);
            setState(419);

            if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
            setState(420);
            match(AutoTenV1Parser::AndAnd);
            setState(421);
            expression(3);
            break;
          }

          case 5: {
            _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleExpression);
            setState(422);

            if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(423);
            match(AutoTenV1Parser::OrOr);
            setState(424);
            expression(2);
            break;
          }

          default: break;
        }
      }
      setState(429);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
    }
  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExprContext
//------------------------------------------------------------------

AutoTenV1Parser::PrimaryExprContext::PrimaryExprContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::OperandContext* AutoTenV1Parser::PrimaryExprContext::operand() {
  return getRuleContext<AutoTenV1Parser::OperandContext>(0);
}

AutoTenV1Parser::ConversionContext* AutoTenV1Parser::PrimaryExprContext::conversion() {
  return getRuleContext<AutoTenV1Parser::ConversionContext>(0);
}

AutoTenV1Parser::MethodExprContext* AutoTenV1Parser::PrimaryExprContext::methodExpr() {
  return getRuleContext<AutoTenV1Parser::MethodExprContext>(0);
}

AutoTenV1Parser::PrimaryExprContext* AutoTenV1Parser::PrimaryExprContext::primaryExpr() {
  return getRuleContext<AutoTenV1Parser::PrimaryExprContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::PrimaryExprContext::Dot() {
  return getToken(AutoTenV1Parser::Dot, 0);
}

tree::TerminalNode* AutoTenV1Parser::PrimaryExprContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

AutoTenV1Parser::IndexContext* AutoTenV1Parser::PrimaryExprContext::index() {
  return getRuleContext<AutoTenV1Parser::IndexContext>(0);
}

AutoTenV1Parser::Slice_Context* AutoTenV1Parser::PrimaryExprContext::slice_() {
  return getRuleContext<AutoTenV1Parser::Slice_Context>(0);
}

AutoTenV1Parser::TypeAssertionContext* AutoTenV1Parser::PrimaryExprContext::typeAssertion() {
  return getRuleContext<AutoTenV1Parser::TypeAssertionContext>(0);
}

AutoTenV1Parser::ArgumentsContext* AutoTenV1Parser::PrimaryExprContext::arguments() {
  return getRuleContext<AutoTenV1Parser::ArgumentsContext>(0);
}

size_t AutoTenV1Parser::PrimaryExprContext::getRuleIndex() const {
  return AutoTenV1Parser::RulePrimaryExpr;
}

void AutoTenV1Parser::PrimaryExprContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterPrimaryExpr(this);
}

void AutoTenV1Parser::PrimaryExprContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitPrimaryExpr(this);
}

std::any AutoTenV1Parser::PrimaryExprContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryExpr(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::PrimaryExprContext* AutoTenV1Parser::primaryExpr() { return primaryExpr(0); }

AutoTenV1Parser::PrimaryExprContext* AutoTenV1Parser::primaryExpr(int precedence) {
  ParserRuleContext* parentContext = _ctx;
  size_t parentState = getState();
  AutoTenV1Parser::PrimaryExprContext* _localctx =
      _tracker.createInstance<PrimaryExprContext>(_ctx, parentState);
  AutoTenV1Parser::PrimaryExprContext* previousContext = _localctx;
  (void)previousContext;  // Silence compiler, in case the context is not used by generated code.
  size_t startState = 60;
  enterRecursionRule(_localctx, 60, AutoTenV1Parser::RulePrimaryExpr, precedence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(434);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
      case 1: {
        setState(431);
        operand();
        break;
      }

      case 2: {
        setState(432);
        conversion();
        break;
      }

      case 3: {
        setState(433);
        methodExpr();
        break;
      }

      default: break;
    }
    _ctx->stop = _input->LT(-1);
    setState(447);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty()) triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<PrimaryExprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RulePrimaryExpr);
        setState(436);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(443);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
          case 1: {
            setState(437);
            match(AutoTenV1Parser::Dot);
            setState(438);
            match(AutoTenV1Parser::Identifier);
            break;
          }

          case 2: {
            setState(439);
            index();
            break;
          }

          case 3: {
            setState(440);
            slice_();
            break;
          }

          case 4: {
            setState(441);
            typeAssertion();
            break;
          }

          case 5: {
            setState(442);
            arguments();
            break;
          }

          default: break;
        }
      }
      setState(449);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx);
    }
  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ConversionContext
//------------------------------------------------------------------

AutoTenV1Parser::ConversionContext::ConversionContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::NonNamedTypeContext* AutoTenV1Parser::ConversionContext::nonNamedType() {
  return getRuleContext<AutoTenV1Parser::NonNamedTypeContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ConversionContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ConversionContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ConversionContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ConversionContext::Comma() {
  return getToken(AutoTenV1Parser::Comma, 0);
}

size_t AutoTenV1Parser::ConversionContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleConversion;
}

void AutoTenV1Parser::ConversionContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterConversion(this);
}

void AutoTenV1Parser::ConversionContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitConversion(this);
}

std::any AutoTenV1Parser::ConversionContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitConversion(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ConversionContext* AutoTenV1Parser::conversion() {
  ConversionContext* _localctx = _tracker.createInstance<ConversionContext>(_ctx, getState());
  enterRule(_localctx, 62, AutoTenV1Parser::RuleConversion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(450);
    nonNamedType();
    setState(451);
    match(AutoTenV1Parser::LeftParen);
    setState(452);
    expression(0);
    setState(454);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Comma) {
      setState(453);
      match(AutoTenV1Parser::Comma);
    }
    setState(456);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonNamedTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::NonNamedTypeContext::NonNamedTypeContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::TypeLitContext* AutoTenV1Parser::NonNamedTypeContext::typeLit() {
  return getRuleContext<AutoTenV1Parser::TypeLitContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::NonNamedTypeContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

AutoTenV1Parser::NonNamedTypeContext* AutoTenV1Parser::NonNamedTypeContext::nonNamedType() {
  return getRuleContext<AutoTenV1Parser::NonNamedTypeContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::NonNamedTypeContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

size_t AutoTenV1Parser::NonNamedTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleNonNamedType;
}

void AutoTenV1Parser::NonNamedTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterNonNamedType(this);
}

void AutoTenV1Parser::NonNamedTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitNonNamedType(this);
}

std::any AutoTenV1Parser::NonNamedTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitNonNamedType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::NonNamedTypeContext* AutoTenV1Parser::nonNamedType() {
  NonNamedTypeContext* _localctx = _tracker.createInstance<NonNamedTypeContext>(_ctx, getState());
  enterRule(_localctx, 64, AutoTenV1Parser::RuleNonNamedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(463);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Map: {
        enterOuterAlt(_localctx, 1);
        setState(458);
        typeLit();
        break;
      }

      case AutoTenV1Parser::LeftParen: {
        enterOuterAlt(_localctx, 2);
        setState(459);
        match(AutoTenV1Parser::LeftParen);
        setState(460);
        nonNamedType();
        setState(461);
        match(AutoTenV1Parser::RightParen);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandContext
//------------------------------------------------------------------

AutoTenV1Parser::OperandContext::OperandContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::LiteralContext* AutoTenV1Parser::OperandContext::literal() {
  return getRuleContext<AutoTenV1Parser::LiteralContext>(0);
}

AutoTenV1Parser::OperandNameContext* AutoTenV1Parser::OperandContext::operandName() {
  return getRuleContext<AutoTenV1Parser::OperandNameContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::OperandContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::OperandContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::OperandContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

size_t AutoTenV1Parser::OperandContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleOperand;
}

void AutoTenV1Parser::OperandContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterOperand(this);
}

void AutoTenV1Parser::OperandContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOperand(this);
}

std::any AutoTenV1Parser::OperandContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitOperand(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::OperandContext* AutoTenV1Parser::operand() {
  OperandContext* _localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 66, AutoTenV1Parser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(465);
        literal();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(466);
        operandName();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(467);
        match(AutoTenV1Parser::LeftParen);
        setState(468);
        expression(0);
        setState(469);
        match(AutoTenV1Parser::RightParen);
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext
//------------------------------------------------------------------

AutoTenV1Parser::ExpressionListContext::ExpressionListContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::ExpressionContext*>
AutoTenV1Parser::ExpressionListContext::expression() {
  return getRuleContexts<AutoTenV1Parser::ExpressionContext>();
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ExpressionListContext::expression(size_t i) {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::ExpressionListContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::ExpressionListContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::ExpressionListContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExpressionList;
}

void AutoTenV1Parser::ExpressionListContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExpressionList(this);
}

void AutoTenV1Parser::ExpressionListContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExpressionList(this);
}

std::any AutoTenV1Parser::ExpressionListContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExpressionList(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::expressionList() {
  ExpressionListContext* _localctx =
      _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 68, AutoTenV1Parser::RuleExpressionList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(473);
    expression(0);
    setState(478);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(474);
        match(AutoTenV1Parser::Comma);
        setState(475);
        expression(0);
      }
      setState(480);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext
//------------------------------------------------------------------

AutoTenV1Parser::IdentifierListContext::IdentifierListContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<tree::TerminalNode*> AutoTenV1Parser::IdentifierListContext::Identifier() {
  return getTokens(AutoTenV1Parser::Identifier);
}

tree::TerminalNode* AutoTenV1Parser::IdentifierListContext::Identifier(size_t i) {
  return getToken(AutoTenV1Parser::Identifier, i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::IdentifierListContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::IdentifierListContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::IdentifierListContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleIdentifierList;
}

void AutoTenV1Parser::IdentifierListContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIdentifierList(this);
}

void AutoTenV1Parser::IdentifierListContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIdentifierList(this);
}

std::any AutoTenV1Parser::IdentifierListContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::IdentifierListContext* AutoTenV1Parser::identifierList() {
  IdentifierListContext* _localctx =
      _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 70, AutoTenV1Parser::RuleIdentifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(481);
    match(AutoTenV1Parser::Identifier);
    setState(486);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::Comma) {
      setState(482);
      match(AutoTenV1Parser::Comma);
      setState(483);
      match(AutoTenV1Parser::Identifier);
      setState(488);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext
//------------------------------------------------------------------

AutoTenV1Parser::LiteralContext::LiteralContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::BasicLitContext* AutoTenV1Parser::LiteralContext::basicLit() {
  return getRuleContext<AutoTenV1Parser::BasicLitContext>(0);
}

AutoTenV1Parser::CompositeLitContext* AutoTenV1Parser::LiteralContext::compositeLit() {
  return getRuleContext<AutoTenV1Parser::CompositeLitContext>(0);
}

AutoTenV1Parser::FunctionLitContext* AutoTenV1Parser::LiteralContext::functionLit() {
  return getRuleContext<AutoTenV1Parser::FunctionLitContext>(0);
}

size_t AutoTenV1Parser::LiteralContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleLiteral;
}

void AutoTenV1Parser::LiteralContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLiteral(this);
}

void AutoTenV1Parser::LiteralContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLiteral(this);
}

std::any AutoTenV1Parser::LiteralContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::LiteralContext* AutoTenV1Parser::literal() {
  LiteralContext* _localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 72, AutoTenV1Parser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(492);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(489);
        basicLit();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(490);
        compositeLit();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(491);
        functionLit();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BasicLitContext
//------------------------------------------------------------------

AutoTenV1Parser::BasicLitContext::BasicLitContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::BasicLitContext::Nilptr() {
  return getToken(AutoTenV1Parser::Nilptr, 0);
}

tree::TerminalNode* AutoTenV1Parser::BasicLitContext::IntegerLiteral() {
  return getToken(AutoTenV1Parser::IntegerLiteral, 0);
}

tree::TerminalNode* AutoTenV1Parser::BasicLitContext::StringLiteral() {
  return getToken(AutoTenV1Parser::StringLiteral, 0);
}

tree::TerminalNode* AutoTenV1Parser::BasicLitContext::FloatingLiteral() {
  return getToken(AutoTenV1Parser::FloatingLiteral, 0);
}

tree::TerminalNode* AutoTenV1Parser::BasicLitContext::CharacterLiteral() {
  return getToken(AutoTenV1Parser::CharacterLiteral, 0);
}

size_t AutoTenV1Parser::BasicLitContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleBasicLit;
}

void AutoTenV1Parser::BasicLitContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBasicLit(this);
}

void AutoTenV1Parser::BasicLitContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBasicLit(this);
}

std::any AutoTenV1Parser::BasicLitContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitBasicLit(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::BasicLitContext* AutoTenV1Parser::basicLit() {
  BasicLitContext* _localctx = _tracker.createInstance<BasicLitContext>(_ctx, getState());
  enterRule(_localctx, 74, AutoTenV1Parser::RuleBasicLit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(494);
    _la = _input->LA(1);
    if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 4194334) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandNameContext
//------------------------------------------------------------------

AutoTenV1Parser::OperandNameContext::OperandNameContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::OperandNameContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::OperandNameContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleOperandName;
}

void AutoTenV1Parser::OperandNameContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterOperandName(this);
}

void AutoTenV1Parser::OperandNameContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitOperandName(this);
}

std::any AutoTenV1Parser::OperandNameContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitOperandName(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::OperandNameContext* AutoTenV1Parser::operandName() {
  OperandNameContext* _localctx = _tracker.createInstance<OperandNameContext>(_ctx, getState());
  enterRule(_localctx, 76, AutoTenV1Parser::RuleOperandName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(AutoTenV1Parser::Identifier);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentContext
//------------------------------------------------------------------

AutoTenV1Parser::QualifiedIdentContext::QualifiedIdentContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<tree::TerminalNode*> AutoTenV1Parser::QualifiedIdentContext::Identifier() {
  return getTokens(AutoTenV1Parser::Identifier);
}

tree::TerminalNode* AutoTenV1Parser::QualifiedIdentContext::Identifier(size_t i) {
  return getToken(AutoTenV1Parser::Identifier, i);
}

tree::TerminalNode* AutoTenV1Parser::QualifiedIdentContext::Dot() {
  return getToken(AutoTenV1Parser::Dot, 0);
}

size_t AutoTenV1Parser::QualifiedIdentContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleQualifiedIdent;
}

void AutoTenV1Parser::QualifiedIdentContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterQualifiedIdent(this);
}

void AutoTenV1Parser::QualifiedIdentContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitQualifiedIdent(this);
}

std::any AutoTenV1Parser::QualifiedIdentContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedIdent(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::QualifiedIdentContext* AutoTenV1Parser::qualifiedIdent() {
  QualifiedIdentContext* _localctx =
      _tracker.createInstance<QualifiedIdentContext>(_ctx, getState());
  enterRule(_localctx, 78, AutoTenV1Parser::RuleQualifiedIdent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(498);
    match(AutoTenV1Parser::Identifier);
    setState(499);
    match(AutoTenV1Parser::Dot);
    setState(500);
    match(AutoTenV1Parser::Identifier);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeLitContext
//------------------------------------------------------------------

AutoTenV1Parser::CompositeLitContext::CompositeLitContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::LiteralTypeContext* AutoTenV1Parser::CompositeLitContext::literalType() {
  return getRuleContext<AutoTenV1Parser::LiteralTypeContext>(0);
}

AutoTenV1Parser::LiteralValueContext* AutoTenV1Parser::CompositeLitContext::literalValue() {
  return getRuleContext<AutoTenV1Parser::LiteralValueContext>(0);
}

size_t AutoTenV1Parser::CompositeLitContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleCompositeLit;
}

void AutoTenV1Parser::CompositeLitContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterCompositeLit(this);
}

void AutoTenV1Parser::CompositeLitContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitCompositeLit(this);
}

std::any AutoTenV1Parser::CompositeLitContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitCompositeLit(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::CompositeLitContext* AutoTenV1Parser::compositeLit() {
  CompositeLitContext* _localctx = _tracker.createInstance<CompositeLitContext>(_ctx, getState());
  enterRule(_localctx, 80, AutoTenV1Parser::RuleCompositeLit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    literalType();
    setState(503);
    literalValue();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::LiteralTypeContext::LiteralTypeContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::StructTypeContext* AutoTenV1Parser::LiteralTypeContext::structType() {
  return getRuleContext<AutoTenV1Parser::StructTypeContext>(0);
}

AutoTenV1Parser::ArrayTypeContext* AutoTenV1Parser::LiteralTypeContext::arrayType() {
  return getRuleContext<AutoTenV1Parser::ArrayTypeContext>(0);
}

AutoTenV1Parser::ElementTypeContext* AutoTenV1Parser::LiteralTypeContext::elementType() {
  return getRuleContext<AutoTenV1Parser::ElementTypeContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::LiteralTypeContext::LeftBracket() {
  return getToken(AutoTenV1Parser::LeftBracket, 0);
}

tree::TerminalNode* AutoTenV1Parser::LiteralTypeContext::Ellipsis() {
  return getToken(AutoTenV1Parser::Ellipsis, 0);
}

tree::TerminalNode* AutoTenV1Parser::LiteralTypeContext::RightBracket() {
  return getToken(AutoTenV1Parser::RightBracket, 0);
}

AutoTenV1Parser::SliceTypeContext* AutoTenV1Parser::LiteralTypeContext::sliceType() {
  return getRuleContext<AutoTenV1Parser::SliceTypeContext>(0);
}

AutoTenV1Parser::MapTypeContext* AutoTenV1Parser::LiteralTypeContext::mapType() {
  return getRuleContext<AutoTenV1Parser::MapTypeContext>(0);
}

AutoTenV1Parser::TypeNameContext* AutoTenV1Parser::LiteralTypeContext::typeName() {
  return getRuleContext<AutoTenV1Parser::TypeNameContext>(0);
}

size_t AutoTenV1Parser::LiteralTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleLiteralType;
}

void AutoTenV1Parser::LiteralTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLiteralType(this);
}

void AutoTenV1Parser::LiteralTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLiteralType(this);
}

std::any AutoTenV1Parser::LiteralTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitLiteralType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::LiteralTypeContext* AutoTenV1Parser::literalType() {
  LiteralTypeContext* _localctx = _tracker.createInstance<LiteralTypeContext>(_ctx, getState());
  enterRule(_localctx, 82, AutoTenV1Parser::RuleLiteralType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(515);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(505);
        structType();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(506);
        arrayType();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(507);
        elementType();
        setState(508);
        match(AutoTenV1Parser::LeftBracket);
        setState(509);
        match(AutoTenV1Parser::Ellipsis);
        setState(510);
        match(AutoTenV1Parser::RightBracket);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(512);
        sliceType();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(513);
        mapType();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(514);
        typeName();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralValueContext
//------------------------------------------------------------------

AutoTenV1Parser::LiteralValueContext::LiteralValueContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::LiteralValueContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::LiteralValueContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

AutoTenV1Parser::ElementListContext* AutoTenV1Parser::LiteralValueContext::elementList() {
  return getRuleContext<AutoTenV1Parser::ElementListContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::LiteralValueContext::Comma() {
  return getToken(AutoTenV1Parser::Comma, 0);
}

size_t AutoTenV1Parser::LiteralValueContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleLiteralValue;
}

void AutoTenV1Parser::LiteralValueContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLiteralValue(this);
}

void AutoTenV1Parser::LiteralValueContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLiteralValue(this);
}

std::any AutoTenV1Parser::LiteralValueContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitLiteralValue(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::LiteralValueContext* AutoTenV1Parser::literalValue() {
  LiteralValueContext* _localctx = _tracker.createInstance<LiteralValueContext>(_ctx, getState());
  enterRule(_localctx, 84, AutoTenV1Parser::RuleLiteralValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(517);
    match(AutoTenV1Parser::LeftBrace);
    setState(522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400210622087198) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(518);
      elementList();
      setState(520);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Comma) {
        setState(519);
        match(AutoTenV1Parser::Comma);
      }
    }
    setState(524);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementListContext
//------------------------------------------------------------------

AutoTenV1Parser::ElementListContext::ElementListContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::KeyedElementContext*>
AutoTenV1Parser::ElementListContext::keyedElement() {
  return getRuleContexts<AutoTenV1Parser::KeyedElementContext>();
}

AutoTenV1Parser::KeyedElementContext* AutoTenV1Parser::ElementListContext::keyedElement(size_t i) {
  return getRuleContext<AutoTenV1Parser::KeyedElementContext>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::ElementListContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::ElementListContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::ElementListContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleElementList;
}

void AutoTenV1Parser::ElementListContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterElementList(this);
}

void AutoTenV1Parser::ElementListContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitElementList(this);
}

std::any AutoTenV1Parser::ElementListContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitElementList(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ElementListContext* AutoTenV1Parser::elementList() {
  ElementListContext* _localctx = _tracker.createInstance<ElementListContext>(_ctx, getState());
  enterRule(_localctx, 86, AutoTenV1Parser::RuleElementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(526);
    keyedElement();
    setState(531);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(527);
        match(AutoTenV1Parser::Comma);
        setState(528);
        keyedElement();
      }
      setState(533);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyedElementContext
//------------------------------------------------------------------

AutoTenV1Parser::KeyedElementContext::KeyedElementContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ElementContext* AutoTenV1Parser::KeyedElementContext::element() {
  return getRuleContext<AutoTenV1Parser::ElementContext>(0);
}

AutoTenV1Parser::KeyContext* AutoTenV1Parser::KeyedElementContext::key() {
  return getRuleContext<AutoTenV1Parser::KeyContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::KeyedElementContext::Colon() {
  return getToken(AutoTenV1Parser::Colon, 0);
}

size_t AutoTenV1Parser::KeyedElementContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleKeyedElement;
}

void AutoTenV1Parser::KeyedElementContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterKeyedElement(this);
}

void AutoTenV1Parser::KeyedElementContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitKeyedElement(this);
}

std::any AutoTenV1Parser::KeyedElementContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitKeyedElement(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::KeyedElementContext* AutoTenV1Parser::keyedElement() {
  KeyedElementContext* _localctx = _tracker.createInstance<KeyedElementContext>(_ctx, getState());
  enterRule(_localctx, 88, AutoTenV1Parser::RuleKeyedElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(537);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
      case 1: {
        setState(534);
        key();
        setState(535);
        match(AutoTenV1Parser::Colon);
        break;
      }

      default: break;
    }
    setState(539);
    element();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyContext ------------------------------------------------------------------

AutoTenV1Parser::KeyContext::KeyContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::KeyContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

AutoTenV1Parser::LiteralValueContext* AutoTenV1Parser::KeyContext::literalValue() {
  return getRuleContext<AutoTenV1Parser::LiteralValueContext>(0);
}

size_t AutoTenV1Parser::KeyContext::getRuleIndex() const { return AutoTenV1Parser::RuleKey; }

void AutoTenV1Parser::KeyContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterKey(this);
}

void AutoTenV1Parser::KeyContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitKey(this);
}

std::any AutoTenV1Parser::KeyContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitKey(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::KeyContext* AutoTenV1Parser::key() {
  KeyContext* _localctx = _tracker.createInstance<KeyContext>(_ctx, getState());
  enterRule(_localctx, 90, AutoTenV1Parser::RuleKey);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(543);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::IntegerLiteral:
      case AutoTenV1Parser::CharacterLiteral:
      case AutoTenV1Parser::FloatingLiteral:
      case AutoTenV1Parser::StringLiteral:
      case AutoTenV1Parser::Nilptr:
      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftParen:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Plus:
      case AutoTenV1Parser::Minus:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Caret:
      case AutoTenV1Parser::And:
      case AutoTenV1Parser::Not:
      case AutoTenV1Parser::At:
      case AutoTenV1Parser::Map:
      case AutoTenV1Parser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(541);
        expression(0);
        break;
      }

      case AutoTenV1Parser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(542);
        literalValue();
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementContext
//------------------------------------------------------------------

AutoTenV1Parser::ElementContext::ElementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ElementContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

AutoTenV1Parser::LiteralValueContext* AutoTenV1Parser::ElementContext::literalValue() {
  return getRuleContext<AutoTenV1Parser::LiteralValueContext>(0);
}

size_t AutoTenV1Parser::ElementContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleElement;
}

void AutoTenV1Parser::ElementContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterElement(this);
}

void AutoTenV1Parser::ElementContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitElement(this);
}

std::any AutoTenV1Parser::ElementContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitElement(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ElementContext* AutoTenV1Parser::element() {
  ElementContext* _localctx = _tracker.createInstance<ElementContext>(_ctx, getState());
  enterRule(_localctx, 92, AutoTenV1Parser::RuleElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(547);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::IntegerLiteral:
      case AutoTenV1Parser::CharacterLiteral:
      case AutoTenV1Parser::FloatingLiteral:
      case AutoTenV1Parser::StringLiteral:
      case AutoTenV1Parser::Nilptr:
      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftParen:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Plus:
      case AutoTenV1Parser::Minus:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Caret:
      case AutoTenV1Parser::And:
      case AutoTenV1Parser::Not:
      case AutoTenV1Parser::At:
      case AutoTenV1Parser::Map:
      case AutoTenV1Parser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(545);
        expression(0);
        break;
      }

      case AutoTenV1Parser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(546);
        literalValue();
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StructTypeContext
//------------------------------------------------------------------

AutoTenV1Parser::StructTypeContext::StructTypeContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::StructTypeContext::Struct() {
  return getToken(AutoTenV1Parser::Struct, 0);
}

tree::TerminalNode* AutoTenV1Parser::StructTypeContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::StructTypeContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

std::vector<AutoTenV1Parser::FieldDeclContext*> AutoTenV1Parser::StructTypeContext::fieldDecl() {
  return getRuleContexts<AutoTenV1Parser::FieldDeclContext>();
}

AutoTenV1Parser::FieldDeclContext* AutoTenV1Parser::StructTypeContext::fieldDecl(size_t i) {
  return getRuleContext<AutoTenV1Parser::FieldDeclContext>(i);
}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::StructTypeContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::StructTypeContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

size_t AutoTenV1Parser::StructTypeContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleStructType;
}

void AutoTenV1Parser::StructTypeContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterStructType(this);
}

void AutoTenV1Parser::StructTypeContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitStructType(this);
}

std::any AutoTenV1Parser::StructTypeContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitStructType(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::StructTypeContext* AutoTenV1Parser::structType() {
  StructTypeContext* _localctx = _tracker.createInstance<StructTypeContext>(_ctx, getState());
  enterRule(_localctx, 94, AutoTenV1Parser::RuleStructType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(549);
    match(AutoTenV1Parser::Struct);
    setState(550);
    match(AutoTenV1Parser::LeftBrace);
    setState(556);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::Star

           || _la == AutoTenV1Parser::Identifier) {
      setState(551);
      fieldDecl();
      setState(552);
      eos();
      setState(558);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(559);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::FieldDeclContext::FieldDeclContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::IdentifierListContext* AutoTenV1Parser::FieldDeclContext::identifierList() {
  return getRuleContext<AutoTenV1Parser::IdentifierListContext>(0);
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::FieldDeclContext::type_() {
  return getRuleContext<AutoTenV1Parser::Type_Context>(0);
}

AutoTenV1Parser::EmbeddedFieldContext* AutoTenV1Parser::FieldDeclContext::embeddedField() {
  return getRuleContext<AutoTenV1Parser::EmbeddedFieldContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::FieldDeclContext::StringLiteral() {
  return getToken(AutoTenV1Parser::StringLiteral, 0);
}

size_t AutoTenV1Parser::FieldDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleFieldDecl;
}

void AutoTenV1Parser::FieldDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFieldDecl(this);
}

void AutoTenV1Parser::FieldDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFieldDecl(this);
}

std::any AutoTenV1Parser::FieldDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitFieldDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::FieldDeclContext* AutoTenV1Parser::fieldDecl() {
  FieldDeclContext* _localctx = _tracker.createInstance<FieldDeclContext>(_ctx, getState());
  enterRule(_localctx, 96, AutoTenV1Parser::RuleFieldDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(565);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
      case 1: {
        setState(561);
        identifierList();
        setState(562);
        type_();
        break;
      }

      case 2: {
        setState(564);
        embeddedField();
        break;
      }

      default: break;
    }
    setState(568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::StringLiteral) {
      setState(567);
      antlrcpp::downCast<FieldDeclContext*>(_localctx)->tag = match(AutoTenV1Parser::StringLiteral);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmbeddedFieldContext
//------------------------------------------------------------------

AutoTenV1Parser::EmbeddedFieldContext::EmbeddedFieldContext(ParserRuleContext* parent,
                                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::TypeNameContext* AutoTenV1Parser::EmbeddedFieldContext::typeName() {
  return getRuleContext<AutoTenV1Parser::TypeNameContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::EmbeddedFieldContext::Star() {
  return getToken(AutoTenV1Parser::Star, 0);
}

size_t AutoTenV1Parser::EmbeddedFieldContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleEmbeddedField;
}

void AutoTenV1Parser::EmbeddedFieldContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterEmbeddedField(this);
}

void AutoTenV1Parser::EmbeddedFieldContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitEmbeddedField(this);
}

std::any AutoTenV1Parser::EmbeddedFieldContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitEmbeddedField(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::EmbeddedFieldContext* AutoTenV1Parser::embeddedField() {
  EmbeddedFieldContext* _localctx = _tracker.createInstance<EmbeddedFieldContext>(_ctx, getState());
  enterRule(_localctx, 98, AutoTenV1Parser::RuleEmbeddedField);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Star) {
      setState(570);
      match(AutoTenV1Parser::Star);
    }
    setState(573);
    typeName();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionLitContext
//------------------------------------------------------------------

AutoTenV1Parser::FunctionLitContext::FunctionLitContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::FunctionLitContext::Function() {
  return getToken(AutoTenV1Parser::Function, 0);
}

AutoTenV1Parser::SignatureContext* AutoTenV1Parser::FunctionLitContext::signature() {
  return getRuleContext<AutoTenV1Parser::SignatureContext>(0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::FunctionLitContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

std::vector<AutoTenV1Parser::CompileFlagsContext*>
AutoTenV1Parser::FunctionLitContext::compileFlags() {
  return getRuleContexts<AutoTenV1Parser::CompileFlagsContext>();
}

AutoTenV1Parser::CompileFlagsContext* AutoTenV1Parser::FunctionLitContext::compileFlags(size_t i) {
  return getRuleContext<AutoTenV1Parser::CompileFlagsContext>(i);
}

size_t AutoTenV1Parser::FunctionLitContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleFunctionLit;
}

void AutoTenV1Parser::FunctionLitContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFunctionLit(this);
}

void AutoTenV1Parser::FunctionLitContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFunctionLit(this);
}

std::any AutoTenV1Parser::FunctionLitContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitFunctionLit(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::FunctionLitContext* AutoTenV1Parser::functionLit() {
  FunctionLitContext* _localctx = _tracker.createInstance<FunctionLitContext>(_ctx, getState());
  enterRule(_localctx, 100, AutoTenV1Parser::RuleFunctionLit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(578);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::At) {
      setState(575);
      compileFlags();
      setState(580);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(581);
    match(AutoTenV1Parser::Function);
    setState(582);
    signature();
    setState(583);
    block();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::FunctionDeclContext::FunctionDeclContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::FunctionDeclContext::Function() {
  return getToken(AutoTenV1Parser::Function, 0);
}

tree::TerminalNode* AutoTenV1Parser::FunctionDeclContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

AutoTenV1Parser::SignatureContext* AutoTenV1Parser::FunctionDeclContext::signature() {
  return getRuleContext<AutoTenV1Parser::SignatureContext>(0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::FunctionDeclContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

size_t AutoTenV1Parser::FunctionDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleFunctionDecl;
}

void AutoTenV1Parser::FunctionDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFunctionDecl(this);
}

void AutoTenV1Parser::FunctionDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFunctionDecl(this);
}

std::any AutoTenV1Parser::FunctionDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitFunctionDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::FunctionDeclContext* AutoTenV1Parser::functionDecl() {
  FunctionDeclContext* _localctx = _tracker.createInstance<FunctionDeclContext>(_ctx, getState());
  enterRule(_localctx, 102, AutoTenV1Parser::RuleFunctionDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    match(AutoTenV1Parser::Function);
    setState(586);
    match(AutoTenV1Parser::Identifier);
    setState(587);
    signature();
    setState(589);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::LeftBrace) {
      setState(588);
      block();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

AutoTenV1Parser::BlockContext::BlockContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::BlockContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::BlockContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

AutoTenV1Parser::StatementListContext* AutoTenV1Parser::BlockContext::statementList() {
  return getRuleContext<AutoTenV1Parser::StatementListContext>(0);
}

size_t AutoTenV1Parser::BlockContext::getRuleIndex() const { return AutoTenV1Parser::RuleBlock; }

void AutoTenV1Parser::BlockContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBlock(this);
}

void AutoTenV1Parser::BlockContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBlock(this);
}

std::any AutoTenV1Parser::BlockContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::block() {
  BlockContext* _localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 104, AutoTenV1Parser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(AutoTenV1Parser::LeftBrace);
    setState(593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400561727537182) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 23) != 0)) {
      setState(592);
      statementList();
    }
    setState(595);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementListContext
//------------------------------------------------------------------

AutoTenV1Parser::StatementListContext::StatementListContext(ParserRuleContext* parent,
                                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::StatementContext*> AutoTenV1Parser::StatementListContext::statement() {
  return getRuleContexts<AutoTenV1Parser::StatementContext>();
}

AutoTenV1Parser::StatementContext* AutoTenV1Parser::StatementListContext::statement(size_t i) {
  return getRuleContext<AutoTenV1Parser::StatementContext>(i);
}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::StatementListContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::StatementListContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::StatementListContext::Semi() {
  return getTokens(AutoTenV1Parser::Semi);
}

tree::TerminalNode* AutoTenV1Parser::StatementListContext::Semi(size_t i) {
  return getToken(AutoTenV1Parser::Semi, i);
}

size_t AutoTenV1Parser::StatementListContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleStatementList;
}

void AutoTenV1Parser::StatementListContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterStatementList(this);
}

void AutoTenV1Parser::StatementListContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitStatementList(this);
}

std::any AutoTenV1Parser::StatementListContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitStatementList(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::StatementListContext* AutoTenV1Parser::statementList() {
  StatementListContext* _localctx = _tracker.createInstance<StatementListContext>(_ctx, getState());
  enterRule(_localctx, 106, AutoTenV1Parser::RuleStatementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(598);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == AutoTenV1Parser::Semi) {
        setState(597);
        match(AutoTenV1Parser::Semi);
      }
      setState(600);
      statement();
      setState(601);
      eos();
      setState(605);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400561727537182) != 0)
             || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 23) != 0));

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext
//------------------------------------------------------------------

AutoTenV1Parser::StatementContext::StatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::DeclarationContext* AutoTenV1Parser::StatementContext::declaration() {
  return getRuleContext<AutoTenV1Parser::DeclarationContext>(0);
}

AutoTenV1Parser::LabeledStmtContext* AutoTenV1Parser::StatementContext::labeledStmt() {
  return getRuleContext<AutoTenV1Parser::LabeledStmtContext>(0);
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::StatementContext::simpleStmt() {
  return getRuleContext<AutoTenV1Parser::SimpleStmtContext>(0);
}

AutoTenV1Parser::ReturnStmtContext* AutoTenV1Parser::StatementContext::returnStmt() {
  return getRuleContext<AutoTenV1Parser::ReturnStmtContext>(0);
}

AutoTenV1Parser::BreakStmtContext* AutoTenV1Parser::StatementContext::breakStmt() {
  return getRuleContext<AutoTenV1Parser::BreakStmtContext>(0);
}

AutoTenV1Parser::ContinueStmtContext* AutoTenV1Parser::StatementContext::continueStmt() {
  return getRuleContext<AutoTenV1Parser::ContinueStmtContext>(0);
}

AutoTenV1Parser::GotoStmtContext* AutoTenV1Parser::StatementContext::gotoStmt() {
  return getRuleContext<AutoTenV1Parser::GotoStmtContext>(0);
}

AutoTenV1Parser::FallthroughStmtContext* AutoTenV1Parser::StatementContext::fallthroughStmt() {
  return getRuleContext<AutoTenV1Parser::FallthroughStmtContext>(0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::StatementContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

AutoTenV1Parser::IfStmtContext* AutoTenV1Parser::StatementContext::ifStmt() {
  return getRuleContext<AutoTenV1Parser::IfStmtContext>(0);
}

AutoTenV1Parser::SwitchStmtContext* AutoTenV1Parser::StatementContext::switchStmt() {
  return getRuleContext<AutoTenV1Parser::SwitchStmtContext>(0);
}

AutoTenV1Parser::ForStmtContext* AutoTenV1Parser::StatementContext::forStmt() {
  return getRuleContext<AutoTenV1Parser::ForStmtContext>(0);
}

AutoTenV1Parser::WhileStmtContext* AutoTenV1Parser::StatementContext::whileStmt() {
  return getRuleContext<AutoTenV1Parser::WhileStmtContext>(0);
}

AutoTenV1Parser::DoWhileStmtContext* AutoTenV1Parser::StatementContext::doWhileStmt() {
  return getRuleContext<AutoTenV1Parser::DoWhileStmtContext>(0);
}

size_t AutoTenV1Parser::StatementContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleStatement;
}

void AutoTenV1Parser::StatementContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterStatement(this);
}

void AutoTenV1Parser::StatementContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitStatement(this);
}

std::any AutoTenV1Parser::StatementContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::StatementContext* AutoTenV1Parser::statement() {
  StatementContext* _localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 108, AutoTenV1Parser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(621);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(607);
        declaration();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(608);
        labeledStmt();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(609);
        simpleStmt();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(610);
        returnStmt();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(611);
        breakStmt();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(612);
        continueStmt();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(613);
        gotoStmt();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(614);
        fallthroughStmt();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(615);
        block();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(616);
        ifStmt();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(617);
        switchStmt();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(618);
        forStmt();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(619);
        whileStmt();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(620);
        doWhileStmt();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::SimpleStmtContext::SimpleStmtContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::IncDecStmtContext* AutoTenV1Parser::SimpleStmtContext::incDecStmt() {
  return getRuleContext<AutoTenV1Parser::IncDecStmtContext>(0);
}

AutoTenV1Parser::AssignmentContext* AutoTenV1Parser::SimpleStmtContext::assignment() {
  return getRuleContext<AutoTenV1Parser::AssignmentContext>(0);
}

AutoTenV1Parser::ExpressionStmtContext* AutoTenV1Parser::SimpleStmtContext::expressionStmt() {
  return getRuleContext<AutoTenV1Parser::ExpressionStmtContext>(0);
}

AutoTenV1Parser::ShortVarDeclContext* AutoTenV1Parser::SimpleStmtContext::shortVarDecl() {
  return getRuleContext<AutoTenV1Parser::ShortVarDeclContext>(0);
}

size_t AutoTenV1Parser::SimpleStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleSimpleStmt;
}

void AutoTenV1Parser::SimpleStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSimpleStmt(this);
}

void AutoTenV1Parser::SimpleStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSimpleStmt(this);
}

std::any AutoTenV1Parser::SimpleStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSimpleStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::simpleStmt() {
  SimpleStmtContext* _localctx = _tracker.createInstance<SimpleStmtContext>(_ctx, getState());
  enterRule(_localctx, 110, AutoTenV1Parser::RuleSimpleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(627);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(623);
        incDecStmt();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(624);
        assignment();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(625);
        expressionStmt();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(626);
        shortVarDecl();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::ExpressionStmtContext::ExpressionStmtContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ExpressionStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

size_t AutoTenV1Parser::ExpressionStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExpressionStmt;
}

void AutoTenV1Parser::ExpressionStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExpressionStmt(this);
}

void AutoTenV1Parser::ExpressionStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExpressionStmt(this);
}

std::any AutoTenV1Parser::ExpressionStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExpressionStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExpressionStmtContext* AutoTenV1Parser::expressionStmt() {
  ExpressionStmtContext* _localctx =
      _tracker.createInstance<ExpressionStmtContext>(_ctx, getState());
  enterRule(_localctx, 112, AutoTenV1Parser::RuleExpressionStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(629);
    expression(0);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncDecStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::IncDecStmtContext::IncDecStmtContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::IncDecStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::IncDecStmtContext::PlusPlus() {
  return getToken(AutoTenV1Parser::PlusPlus, 0);
}

size_t AutoTenV1Parser::IncDecStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleIncDecStmt;
}

void AutoTenV1Parser::IncDecStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIncDecStmt(this);
}

void AutoTenV1Parser::IncDecStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIncDecStmt(this);
}

std::any AutoTenV1Parser::IncDecStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitIncDecStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::IncDecStmtContext* AutoTenV1Parser::incDecStmt() {
  IncDecStmtContext* _localctx = _tracker.createInstance<IncDecStmtContext>(_ctx, getState());
  enterRule(_localctx, 114, AutoTenV1Parser::RuleIncDecStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    expression(0);
    setState(632);
    _la = _input->LA(1);
    if (!(_la == AutoTenV1Parser::PlusPlus)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext
//------------------------------------------------------------------

AutoTenV1Parser::AssignmentContext::AssignmentContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::ExpressionListContext*>
AutoTenV1Parser::AssignmentContext::expressionList() {
  return getRuleContexts<AutoTenV1Parser::ExpressionListContext>();
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::AssignmentContext::expressionList(
    size_t i) {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(i);
}

AutoTenV1Parser::Assign_opContext* AutoTenV1Parser::AssignmentContext::assign_op() {
  return getRuleContext<AutoTenV1Parser::Assign_opContext>(0);
}

size_t AutoTenV1Parser::AssignmentContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleAssignment;
}

void AutoTenV1Parser::AssignmentContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAssignment(this);
}

void AutoTenV1Parser::AssignmentContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAssignment(this);
}

std::any AutoTenV1Parser::AssignmentContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitAssignment(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::AssignmentContext* AutoTenV1Parser::assignment() {
  AssignmentContext* _localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 116, AutoTenV1Parser::RuleAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(634);
    expressionList();
    setState(635);
    assign_op();
    setState(636);
    expressionList();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_opContext
//------------------------------------------------------------------

AutoTenV1Parser::Assign_opContext::Assign_opContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Equal() {
  return getToken(AutoTenV1Parser::Equal, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Plus() {
  return getToken(AutoTenV1Parser::Plus, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Minus() {
  return getToken(AutoTenV1Parser::Minus, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Or() {
  return getToken(AutoTenV1Parser::Or, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Caret() {
  return getToken(AutoTenV1Parser::Caret, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Star() {
  return getToken(AutoTenV1Parser::Star, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Div() {
  return getToken(AutoTenV1Parser::Div, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::Mod() {
  return getToken(AutoTenV1Parser::Mod, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::LeftShift() {
  return getToken(AutoTenV1Parser::LeftShift, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::RightShift() {
  return getToken(AutoTenV1Parser::RightShift, 0);
}

tree::TerminalNode* AutoTenV1Parser::Assign_opContext::And() {
  return getToken(AutoTenV1Parser::And, 0);
}

size_t AutoTenV1Parser::Assign_opContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleAssign_op;
}

void AutoTenV1Parser::Assign_opContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterAssign_op(this);
}

void AutoTenV1Parser::Assign_opContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitAssign_op(this);
}

std::any AutoTenV1Parser::Assign_opContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitAssign_op(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::Assign_opContext* AutoTenV1Parser::assign_op() {
  Assign_opContext* _localctx = _tracker.createInstance<Assign_opContext>(_ctx, getState());
  enterRule(_localctx, 118, AutoTenV1Parser::RuleAssign_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(639);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 49) & ~0x3fULL) == 0) && ((1ULL << (_la - 49)) & 49407) != 0)) {
      setState(638);
      _la = _input->LA(1);
      if (!(((((_la - 49) & ~0x3fULL) == 0) && ((1ULL << (_la - 49)) & 49407) != 0))) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(641);
    match(AutoTenV1Parser::Equal);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShortVarDeclContext
//------------------------------------------------------------------

AutoTenV1Parser::ShortVarDeclContext::ShortVarDeclContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::IdentifierListContext* AutoTenV1Parser::ShortVarDeclContext::identifierList() {
  return getRuleContext<AutoTenV1Parser::IdentifierListContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ShortVarDeclContext::DeclareAssign() {
  return getToken(AutoTenV1Parser::DeclareAssign, 0);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::ShortVarDeclContext::expressionList() {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(0);
}

size_t AutoTenV1Parser::ShortVarDeclContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleShortVarDecl;
}

void AutoTenV1Parser::ShortVarDeclContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterShortVarDecl(this);
}

void AutoTenV1Parser::ShortVarDeclContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitShortVarDecl(this);
}

std::any AutoTenV1Parser::ShortVarDeclContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitShortVarDecl(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ShortVarDeclContext* AutoTenV1Parser::shortVarDecl() {
  ShortVarDeclContext* _localctx = _tracker.createInstance<ShortVarDeclContext>(_ctx, getState());
  enterRule(_localctx, 120, AutoTenV1Parser::RuleShortVarDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    identifierList();
    setState(644);
    match(AutoTenV1Parser::DeclareAssign);
    setState(645);
    expressionList();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::EmptyStmtContext::EmptyStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::EmptyStmtContext::Semi() {
  return getToken(AutoTenV1Parser::Semi, 0);
}

size_t AutoTenV1Parser::EmptyStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleEmptyStmt;
}

void AutoTenV1Parser::EmptyStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterEmptyStmt(this);
}

void AutoTenV1Parser::EmptyStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitEmptyStmt(this);
}

std::any AutoTenV1Parser::EmptyStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitEmptyStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::EmptyStmtContext* AutoTenV1Parser::emptyStmt() {
  EmptyStmtContext* _localctx = _tracker.createInstance<EmptyStmtContext>(_ctx, getState());
  enterRule(_localctx, 122, AutoTenV1Parser::RuleEmptyStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(647);
    match(AutoTenV1Parser::Semi);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::LabeledStmtContext::LabeledStmtContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::LabeledStmtContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

tree::TerminalNode* AutoTenV1Parser::LabeledStmtContext::Colon() {
  return getToken(AutoTenV1Parser::Colon, 0);
}

AutoTenV1Parser::StatementContext* AutoTenV1Parser::LabeledStmtContext::statement() {
  return getRuleContext<AutoTenV1Parser::StatementContext>(0);
}

size_t AutoTenV1Parser::LabeledStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleLabeledStmt;
}

void AutoTenV1Parser::LabeledStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterLabeledStmt(this);
}

void AutoTenV1Parser::LabeledStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitLabeledStmt(this);
}

std::any AutoTenV1Parser::LabeledStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitLabeledStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::LabeledStmtContext* AutoTenV1Parser::labeledStmt() {
  LabeledStmtContext* _localctx = _tracker.createInstance<LabeledStmtContext>(_ctx, getState());
  enterRule(_localctx, 124, AutoTenV1Parser::RuleLabeledStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(AutoTenV1Parser::Identifier);
    setState(650);
    match(AutoTenV1Parser::Colon);
    setState(652);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400561727537182) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(651);
      statement();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ReturnStmtContext::Return() {
  return getToken(AutoTenV1Parser::Return, 0);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::ReturnStmtContext::expressionList() {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(0);
}

size_t AutoTenV1Parser::ReturnStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleReturnStmt;
}

void AutoTenV1Parser::ReturnStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterReturnStmt(this);
}

void AutoTenV1Parser::ReturnStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitReturnStmt(this);
}

std::any AutoTenV1Parser::ReturnStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitReturnStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ReturnStmtContext* AutoTenV1Parser::returnStmt() {
  ReturnStmtContext* _localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 126, AutoTenV1Parser::RuleReturnStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(654);
    match(AutoTenV1Parser::Return);
    setState(656);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(655);
      expressionList();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BreakStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::BreakStmtContext::BreakStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::BreakStmtContext::Break() {
  return getToken(AutoTenV1Parser::Break, 0);
}

tree::TerminalNode* AutoTenV1Parser::BreakStmtContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::BreakStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleBreakStmt;
}

void AutoTenV1Parser::BreakStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterBreakStmt(this);
}

void AutoTenV1Parser::BreakStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitBreakStmt(this);
}

std::any AutoTenV1Parser::BreakStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitBreakStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::BreakStmtContext* AutoTenV1Parser::breakStmt() {
  BreakStmtContext* _localctx = _tracker.createInstance<BreakStmtContext>(_ctx, getState());
  enterRule(_localctx, 128, AutoTenV1Parser::RuleBreakStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(658);
    match(AutoTenV1Parser::Break);
    setState(660);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Identifier) {
      setState(659);
      match(AutoTenV1Parser::Identifier);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContinueStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::ContinueStmtContext::ContinueStmtContext(ParserRuleContext* parent,
                                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ContinueStmtContext::Continue() {
  return getToken(AutoTenV1Parser::Continue, 0);
}

tree::TerminalNode* AutoTenV1Parser::ContinueStmtContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::ContinueStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleContinueStmt;
}

void AutoTenV1Parser::ContinueStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterContinueStmt(this);
}

void AutoTenV1Parser::ContinueStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitContinueStmt(this);
}

std::any AutoTenV1Parser::ContinueStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitContinueStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ContinueStmtContext* AutoTenV1Parser::continueStmt() {
  ContinueStmtContext* _localctx = _tracker.createInstance<ContinueStmtContext>(_ctx, getState());
  enterRule(_localctx, 130, AutoTenV1Parser::RuleContinueStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(662);
    match(AutoTenV1Parser::Continue);
    setState(664);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Identifier) {
      setState(663);
      match(AutoTenV1Parser::Identifier);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GotoStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::GotoStmtContext::GotoStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::GotoStmtContext::Goto() {
  return getToken(AutoTenV1Parser::Goto, 0);
}

tree::TerminalNode* AutoTenV1Parser::GotoStmtContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

size_t AutoTenV1Parser::GotoStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleGotoStmt;
}

void AutoTenV1Parser::GotoStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterGotoStmt(this);
}

void AutoTenV1Parser::GotoStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitGotoStmt(this);
}

std::any AutoTenV1Parser::GotoStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitGotoStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::GotoStmtContext* AutoTenV1Parser::gotoStmt() {
  GotoStmtContext* _localctx = _tracker.createInstance<GotoStmtContext>(_ctx, getState());
  enterRule(_localctx, 132, AutoTenV1Parser::RuleGotoStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(666);
    match(AutoTenV1Parser::Goto);
    setState(667);
    match(AutoTenV1Parser::Identifier);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FallthroughStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::FallthroughStmtContext::FallthroughStmtContext(ParserRuleContext* parent,
                                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::FallthroughStmtContext::Fallthrough() {
  return getToken(AutoTenV1Parser::Fallthrough, 0);
}

size_t AutoTenV1Parser::FallthroughStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleFallthroughStmt;
}

void AutoTenV1Parser::FallthroughStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterFallthroughStmt(this);
}

void AutoTenV1Parser::FallthroughStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitFallthroughStmt(this);
}

std::any AutoTenV1Parser::FallthroughStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitFallthroughStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::FallthroughStmtContext* AutoTenV1Parser::fallthroughStmt() {
  FallthroughStmtContext* _localctx =
      _tracker.createInstance<FallthroughStmtContext>(_ctx, getState());
  enterRule(_localctx, 134, AutoTenV1Parser::RuleFallthroughStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(669);
    match(AutoTenV1Parser::Fallthrough);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtContext ------------------------------------------------------------------

AutoTenV1Parser::IfStmtContext::IfStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::IfStmtContext::If() {
  return getToken(AutoTenV1Parser::If, 0);
}

tree::TerminalNode* AutoTenV1Parser::IfStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::IfStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

std::vector<AutoTenV1Parser::BlockContext*> AutoTenV1Parser::IfStmtContext::block() {
  return getRuleContexts<AutoTenV1Parser::BlockContext>();
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::IfStmtContext::block(size_t i) {
  return getRuleContext<AutoTenV1Parser::BlockContext>(i);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::IfStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::IfStmtContext::eos() {
  return getRuleContext<AutoTenV1Parser::EosContext>(0);
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::IfStmtContext::simpleStmt() {
  return getRuleContext<AutoTenV1Parser::SimpleStmtContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::IfStmtContext::Else() {
  return getToken(AutoTenV1Parser::Else, 0);
}

AutoTenV1Parser::IfStmtContext* AutoTenV1Parser::IfStmtContext::ifStmt() {
  return getRuleContext<AutoTenV1Parser::IfStmtContext>(0);
}

size_t AutoTenV1Parser::IfStmtContext::getRuleIndex() const { return AutoTenV1Parser::RuleIfStmt; }

void AutoTenV1Parser::IfStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterIfStmt(this);
}

void AutoTenV1Parser::IfStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitIfStmt(this);
}

std::any AutoTenV1Parser::IfStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitIfStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::IfStmtContext* AutoTenV1Parser::ifStmt() {
  IfStmtContext* _localctx = _tracker.createInstance<IfStmtContext>(_ctx, getState());
  enterRule(_localctx, 136, AutoTenV1Parser::RuleIfStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    match(AutoTenV1Parser::If);
    setState(672);
    match(AutoTenV1Parser::LeftParen);
    setState(681);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(673);
        expression(0);
        break;
      }

      case 2: {
        setState(674);
        eos();
        setState(675);
        expression(0);
        break;
      }

      case 3: {
        setState(677);
        simpleStmt();
        setState(678);
        eos();
        setState(679);
        expression(0);
        break;
      }

      default: break;
    }
    setState(683);
    match(AutoTenV1Parser::RightParen);
    setState(684);
    block();
    setState(690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == AutoTenV1Parser::Else) {
      setState(685);
      match(AutoTenV1Parser::Else);
      setState(688);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case AutoTenV1Parser::If: {
          setState(686);
          ifStmt();
          break;
        }

        case AutoTenV1Parser::LeftBrace: {
          setState(687);
          block();
          break;
        }

        default: throw NoViableAltException(this);
      }
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::SwitchStmtContext::SwitchStmtContext(ParserRuleContext* parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExprSwitchStmtContext* AutoTenV1Parser::SwitchStmtContext::exprSwitchStmt() {
  return getRuleContext<AutoTenV1Parser::ExprSwitchStmtContext>(0);
}

AutoTenV1Parser::TypeSwitchStmtContext* AutoTenV1Parser::SwitchStmtContext::typeSwitchStmt() {
  return getRuleContext<AutoTenV1Parser::TypeSwitchStmtContext>(0);
}

size_t AutoTenV1Parser::SwitchStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleSwitchStmt;
}

void AutoTenV1Parser::SwitchStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterSwitchStmt(this);
}

void AutoTenV1Parser::SwitchStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitSwitchStmt(this);
}

std::any AutoTenV1Parser::SwitchStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::SwitchStmtContext* AutoTenV1Parser::switchStmt() {
  SwitchStmtContext* _localctx = _tracker.createInstance<SwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 138, AutoTenV1Parser::RuleSwitchStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(694);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(692);
        exprSwitchStmt();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(693);
        typeSwitchStmt();
        break;
      }

      default: break;
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::ExprSwitchStmtContext::ExprSwitchStmtContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchStmtContext::Switch() {
  return getToken(AutoTenV1Parser::Switch, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchStmtContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchStmtContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::ExprSwitchStmtContext::eos() {
  return getRuleContext<AutoTenV1Parser::EosContext>(0);
}

std::vector<AutoTenV1Parser::ExprCaseClauseContext*>
AutoTenV1Parser::ExprSwitchStmtContext::exprCaseClause() {
  return getRuleContexts<AutoTenV1Parser::ExprCaseClauseContext>();
}

AutoTenV1Parser::ExprCaseClauseContext* AutoTenV1Parser::ExprSwitchStmtContext::exprCaseClause(
    size_t i) {
  return getRuleContext<AutoTenV1Parser::ExprCaseClauseContext>(i);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ExprSwitchStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::ExprSwitchStmtContext::simpleStmt() {
  return getRuleContext<AutoTenV1Parser::SimpleStmtContext>(0);
}

size_t AutoTenV1Parser::ExprSwitchStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExprSwitchStmt;
}

void AutoTenV1Parser::ExprSwitchStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExprSwitchStmt(this);
}

void AutoTenV1Parser::ExprSwitchStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExprSwitchStmt(this);
}

std::any AutoTenV1Parser::ExprSwitchStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExprSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExprSwitchStmtContext* AutoTenV1Parser::exprSwitchStmt() {
  ExprSwitchStmtContext* _localctx =
      _tracker.createInstance<ExprSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 140, AutoTenV1Parser::RuleExprSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(696);
    match(AutoTenV1Parser::Switch);
    setState(697);
    match(AutoTenV1Parser::LeftParen);
    setState(708);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
      case 1: {
        setState(699);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(698);
          expression(0);
        }
        break;
      }

      case 2: {
        setState(702);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(701);
          simpleStmt();
        }
        setState(704);
        eos();
        setState(706);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(705);
          expression(0);
        }
        break;
      }

      default: break;
    }
    setState(710);
    match(AutoTenV1Parser::RightParen);
    setState(711);
    match(AutoTenV1Parser::LeftBrace);
    setState(715);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::Case

           || _la == AutoTenV1Parser::Default) {
      setState(712);
      exprCaseClause();
      setState(717);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(718);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprCaseClauseContext
//------------------------------------------------------------------

AutoTenV1Parser::ExprCaseClauseContext::ExprCaseClauseContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::ExprSwitchCaseContext* AutoTenV1Parser::ExprCaseClauseContext::exprSwitchCase() {
  return getRuleContext<AutoTenV1Parser::ExprSwitchCaseContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ExprCaseClauseContext::Colon() {
  return getToken(AutoTenV1Parser::Colon, 0);
}

AutoTenV1Parser::StatementListContext* AutoTenV1Parser::ExprCaseClauseContext::statementList() {
  return getRuleContext<AutoTenV1Parser::StatementListContext>(0);
}

size_t AutoTenV1Parser::ExprCaseClauseContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExprCaseClause;
}

void AutoTenV1Parser::ExprCaseClauseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExprCaseClause(this);
}

void AutoTenV1Parser::ExprCaseClauseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExprCaseClause(this);
}

std::any AutoTenV1Parser::ExprCaseClauseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExprCaseClause(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExprCaseClauseContext* AutoTenV1Parser::exprCaseClause() {
  ExprCaseClauseContext* _localctx =
      _tracker.createInstance<ExprCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 142, AutoTenV1Parser::RuleExprCaseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(720);
    exprSwitchCase();
    setState(721);
    match(AutoTenV1Parser::Colon);
    setState(723);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400561727537182) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 23) != 0)) {
      setState(722);
      statementList();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprSwitchCaseContext
//------------------------------------------------------------------

AutoTenV1Parser::ExprSwitchCaseContext::ExprSwitchCaseContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchCaseContext::Case() {
  return getToken(AutoTenV1Parser::Case, 0);
}

AutoTenV1Parser::ExpressionListContext* AutoTenV1Parser::ExprSwitchCaseContext::expressionList() {
  return getRuleContext<AutoTenV1Parser::ExpressionListContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::ExprSwitchCaseContext::Default() {
  return getToken(AutoTenV1Parser::Default, 0);
}

size_t AutoTenV1Parser::ExprSwitchCaseContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleExprSwitchCase;
}

void AutoTenV1Parser::ExprSwitchCaseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterExprSwitchCase(this);
}

void AutoTenV1Parser::ExprSwitchCaseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitExprSwitchCase(this);
}

std::any AutoTenV1Parser::ExprSwitchCaseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitExprSwitchCase(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ExprSwitchCaseContext* AutoTenV1Parser::exprSwitchCase() {
  ExprSwitchCaseContext* _localctx =
      _tracker.createInstance<ExprSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 144, AutoTenV1Parser::RuleExprSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(728);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Case: {
        enterOuterAlt(_localctx, 1);
        setState(725);
        match(AutoTenV1Parser::Case);
        setState(726);
        expressionList();
        break;
      }

      case AutoTenV1Parser::Default: {
        enterOuterAlt(_localctx, 2);
        setState(727);
        match(AutoTenV1Parser::Default);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeSwitchStmtContext::TypeSwitchStmtContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchStmtContext::Switch() {
  return getToken(AutoTenV1Parser::Switch, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchStmtContext::LeftBrace() {
  return getToken(AutoTenV1Parser::LeftBrace, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchStmtContext::RightBrace() {
  return getToken(AutoTenV1Parser::RightBrace, 0);
}

AutoTenV1Parser::TypeSwitchGuardContext* AutoTenV1Parser::TypeSwitchStmtContext::typeSwitchGuard() {
  return getRuleContext<AutoTenV1Parser::TypeSwitchGuardContext>(0);
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::TypeSwitchStmtContext::eos() {
  return getRuleContext<AutoTenV1Parser::EosContext>(0);
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::TypeSwitchStmtContext::simpleStmt() {
  return getRuleContext<AutoTenV1Parser::SimpleStmtContext>(0);
}

std::vector<AutoTenV1Parser::TypeCaseClauseContext*>
AutoTenV1Parser::TypeSwitchStmtContext::typeCaseClause() {
  return getRuleContexts<AutoTenV1Parser::TypeCaseClauseContext>();
}

AutoTenV1Parser::TypeCaseClauseContext* AutoTenV1Parser::TypeSwitchStmtContext::typeCaseClause(
    size_t i) {
  return getRuleContext<AutoTenV1Parser::TypeCaseClauseContext>(i);
}

size_t AutoTenV1Parser::TypeSwitchStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeSwitchStmt;
}

void AutoTenV1Parser::TypeSwitchStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeSwitchStmt(this);
}

void AutoTenV1Parser::TypeSwitchStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeSwitchStmt(this);
}

std::any AutoTenV1Parser::TypeSwitchStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeSwitchStmtContext* AutoTenV1Parser::typeSwitchStmt() {
  TypeSwitchStmtContext* _localctx =
      _tracker.createInstance<TypeSwitchStmtContext>(_ctx, getState());
  enterRule(_localctx, 146, AutoTenV1Parser::RuleTypeSwitchStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(730);
    match(AutoTenV1Parser::Switch);
    setState(731);
    match(AutoTenV1Parser::LeftParen);
    setState(740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
      case 1: {
        setState(732);
        typeSwitchGuard();
        break;
      }

      case 2: {
        setState(733);
        eos();
        setState(734);
        typeSwitchGuard();
        break;
      }

      case 3: {
        setState(736);
        simpleStmt();
        setState(737);
        eos();
        setState(738);
        typeSwitchGuard();
        break;
      }

      default: break;
    }
    setState(742);
    match(AutoTenV1Parser::RightParen);
    setState(743);
    match(AutoTenV1Parser::LeftBrace);
    setState(747);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::Case

           || _la == AutoTenV1Parser::Default) {
      setState(744);
      typeCaseClause();
      setState(749);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(750);
    match(AutoTenV1Parser::RightBrace);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchGuardContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeSwitchGuardContext::TypeSwitchGuardContext(ParserRuleContext* parent,
                                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::PrimaryExprContext* AutoTenV1Parser::TypeSwitchGuardContext::primaryExpr() {
  return getRuleContext<AutoTenV1Parser::PrimaryExprContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::Dot() {
  return getToken(AutoTenV1Parser::Dot, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::Type() {
  return getToken(AutoTenV1Parser::Type, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::Identifier() {
  return getToken(AutoTenV1Parser::Identifier, 0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchGuardContext::DeclareAssign() {
  return getToken(AutoTenV1Parser::DeclareAssign, 0);
}

size_t AutoTenV1Parser::TypeSwitchGuardContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeSwitchGuard;
}

void AutoTenV1Parser::TypeSwitchGuardContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeSwitchGuard(this);
}

void AutoTenV1Parser::TypeSwitchGuardContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeSwitchGuard(this);
}

std::any AutoTenV1Parser::TypeSwitchGuardContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchGuard(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeSwitchGuardContext* AutoTenV1Parser::typeSwitchGuard() {
  TypeSwitchGuardContext* _localctx =
      _tracker.createInstance<TypeSwitchGuardContext>(_ctx, getState());
  enterRule(_localctx, 148, AutoTenV1Parser::RuleTypeSwitchGuard);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(754);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
      case 1: {
        setState(752);
        match(AutoTenV1Parser::Identifier);
        setState(753);
        match(AutoTenV1Parser::DeclareAssign);
        break;
      }

      default: break;
    }
    setState(756);
    primaryExpr(0);
    setState(757);
    match(AutoTenV1Parser::Dot);
    setState(758);
    match(AutoTenV1Parser::LeftParen);
    setState(759);
    match(AutoTenV1Parser::Type);
    setState(760);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeCaseClauseContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeCaseClauseContext::TypeCaseClauseContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

AutoTenV1Parser::TypeSwitchCaseContext* AutoTenV1Parser::TypeCaseClauseContext::typeSwitchCase() {
  return getRuleContext<AutoTenV1Parser::TypeSwitchCaseContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeCaseClauseContext::Colon() {
  return getToken(AutoTenV1Parser::Colon, 0);
}

AutoTenV1Parser::StatementListContext* AutoTenV1Parser::TypeCaseClauseContext::statementList() {
  return getRuleContext<AutoTenV1Parser::StatementListContext>(0);
}

size_t AutoTenV1Parser::TypeCaseClauseContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeCaseClause;
}

void AutoTenV1Parser::TypeCaseClauseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeCaseClause(this);
}

void AutoTenV1Parser::TypeCaseClauseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeCaseClause(this);
}

std::any AutoTenV1Parser::TypeCaseClauseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeCaseClause(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeCaseClauseContext* AutoTenV1Parser::typeCaseClause() {
  TypeCaseClauseContext* _localctx =
      _tracker.createInstance<TypeCaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 150, AutoTenV1Parser::RuleTypeCaseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(762);
    typeSwitchCase();
    setState(763);
    match(AutoTenV1Parser::Colon);
    setState(765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346400561727537182) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 23) != 0)) {
      setState(764);
      statementList();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSwitchCaseContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeSwitchCaseContext::TypeSwitchCaseContext(ParserRuleContext* parent,
                                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchCaseContext::Case() {
  return getToken(AutoTenV1Parser::Case, 0);
}

AutoTenV1Parser::TypeListContext* AutoTenV1Parser::TypeSwitchCaseContext::typeList() {
  return getRuleContext<AutoTenV1Parser::TypeListContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::TypeSwitchCaseContext::Default() {
  return getToken(AutoTenV1Parser::Default, 0);
}

size_t AutoTenV1Parser::TypeSwitchCaseContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeSwitchCase;
}

void AutoTenV1Parser::TypeSwitchCaseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeSwitchCase(this);
}

void AutoTenV1Parser::TypeSwitchCaseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeSwitchCase(this);
}

std::any AutoTenV1Parser::TypeSwitchCaseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeSwitchCase(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeSwitchCaseContext* AutoTenV1Parser::typeSwitchCase() {
  TypeSwitchCaseContext* _localctx =
      _tracker.createInstance<TypeSwitchCaseContext>(_ctx, getState());
  enterRule(_localctx, 152, AutoTenV1Parser::RuleTypeSwitchCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(770);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Case: {
        enterOuterAlt(_localctx, 1);
        setState(767);
        match(AutoTenV1Parser::Case);
        setState(768);
        typeList();
        break;
      }

      case AutoTenV1Parser::Default: {
        enterOuterAlt(_localctx, 2);
        setState(769);
        match(AutoTenV1Parser::Default);
        break;
      }

      default: throw NoViableAltException(this);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeListContext
//------------------------------------------------------------------

AutoTenV1Parser::TypeListContext::TypeListContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::Type_Context*> AutoTenV1Parser::TypeListContext::type_() {
  return getRuleContexts<AutoTenV1Parser::Type_Context>();
}

AutoTenV1Parser::Type_Context* AutoTenV1Parser::TypeListContext::type_(size_t i) {
  return getRuleContext<AutoTenV1Parser::Type_Context>(i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::TypeListContext::Nilptr() {
  return getTokens(AutoTenV1Parser::Nilptr);
}

tree::TerminalNode* AutoTenV1Parser::TypeListContext::Nilptr(size_t i) {
  return getToken(AutoTenV1Parser::Nilptr, i);
}

std::vector<tree::TerminalNode*> AutoTenV1Parser::TypeListContext::Comma() {
  return getTokens(AutoTenV1Parser::Comma);
}

tree::TerminalNode* AutoTenV1Parser::TypeListContext::Comma(size_t i) {
  return getToken(AutoTenV1Parser::Comma, i);
}

size_t AutoTenV1Parser::TypeListContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleTypeList;
}

void AutoTenV1Parser::TypeListContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterTypeList(this);
}

void AutoTenV1Parser::TypeListContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitTypeList(this);
}

std::any AutoTenV1Parser::TypeListContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitTypeList(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::TypeListContext* AutoTenV1Parser::typeList() {
  TypeListContext* _localctx = _tracker.createInstance<TypeListContext>(_ctx, getState());
  enterRule(_localctx, 154, AutoTenV1Parser::RuleTypeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case AutoTenV1Parser::Function:
      case AutoTenV1Parser::Struct:
      case AutoTenV1Parser::Impl:
      case AutoTenV1Parser::LeftParen:
      case AutoTenV1Parser::LeftBracket:
      case AutoTenV1Parser::Star:
      case AutoTenV1Parser::Map:
      case AutoTenV1Parser::Identifier: {
        setState(772);
        type_();
        break;
      }

      case AutoTenV1Parser::Nilptr: {
        setState(773);
        match(AutoTenV1Parser::Nilptr);
        break;
      }

      default: throw NoViableAltException(this);
    }
    setState(783);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == AutoTenV1Parser::Comma) {
      setState(776);
      match(AutoTenV1Parser::Comma);
      setState(779);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case AutoTenV1Parser::Function:
        case AutoTenV1Parser::Struct:
        case AutoTenV1Parser::Impl:
        case AutoTenV1Parser::LeftParen:
        case AutoTenV1Parser::LeftBracket:
        case AutoTenV1Parser::Star:
        case AutoTenV1Parser::Map:
        case AutoTenV1Parser::Identifier: {
          setState(777);
          type_();
          break;
        }

        case AutoTenV1Parser::Nilptr: {
          setState(778);
          match(AutoTenV1Parser::Nilptr);
          break;
        }

        default: throw NoViableAltException(this);
      }
      setState(785);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::ForStmtContext::ForStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::ForStmtContext::For() {
  return getToken(AutoTenV1Parser::For, 0);
}

tree::TerminalNode* AutoTenV1Parser::ForStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::ForStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::ForStmtContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

AutoTenV1Parser::ForClauseContext* AutoTenV1Parser::ForStmtContext::forClause() {
  return getRuleContext<AutoTenV1Parser::ForClauseContext>(0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ForStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

size_t AutoTenV1Parser::ForStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleForStmt;
}

void AutoTenV1Parser::ForStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterForStmt(this);
}

void AutoTenV1Parser::ForStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitForStmt(this);
}

std::any AutoTenV1Parser::ForStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitForStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ForStmtContext* AutoTenV1Parser::forStmt() {
  ForStmtContext* _localctx = _tracker.createInstance<ForStmtContext>(_ctx, getState());
  enterRule(_localctx, 156, AutoTenV1Parser::RuleForStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    match(AutoTenV1Parser::For);
    setState(787);
    match(AutoTenV1Parser::LeftParen);
    setState(792);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
      case 1: {
        setState(789);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
            || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
          setState(788);
          expression(0);
        }
        break;
      }

      case 2: {
        setState(791);
        forClause();
        break;
      }

      default: break;
    }
    setState(794);
    match(AutoTenV1Parser::RightParen);
    setState(795);
    block();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForClauseContext
//------------------------------------------------------------------

AutoTenV1Parser::ForClauseContext::ForClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<AutoTenV1Parser::EosContext*> AutoTenV1Parser::ForClauseContext::eos() {
  return getRuleContexts<AutoTenV1Parser::EosContext>();
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::ForClauseContext::eos(size_t i) {
  return getRuleContext<AutoTenV1Parser::EosContext>(i);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::ForClauseContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

std::vector<AutoTenV1Parser::SimpleStmtContext*> AutoTenV1Parser::ForClauseContext::simpleStmt() {
  return getRuleContexts<AutoTenV1Parser::SimpleStmtContext>();
}

AutoTenV1Parser::SimpleStmtContext* AutoTenV1Parser::ForClauseContext::simpleStmt(size_t i) {
  return getRuleContext<AutoTenV1Parser::SimpleStmtContext>(i);
}

size_t AutoTenV1Parser::ForClauseContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleForClause;
}

void AutoTenV1Parser::ForClauseContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterForClause(this);
}

void AutoTenV1Parser::ForClauseContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitForClause(this);
}

std::any AutoTenV1Parser::ForClauseContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitForClause(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::ForClauseContext* AutoTenV1Parser::forClause() {
  ForClauseContext* _localctx = _tracker.createInstance<ForClauseContext>(_ctx, getState());
  enterRule(_localctx, 158, AutoTenV1Parser::RuleForClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(798);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(797);
      antlrcpp::downCast<ForClauseContext*>(_localctx)->initStmt = simpleStmt();
    }
    setState(800);
    eos();
    setState(802);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(801);
      expression(0);
    }
    setState(804);
    eos();
    setState(806);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 346259473133731870) != 0)
        || ((((_la - 79) & ~0x3fULL) == 0) && ((1ULL << (_la - 79)) & 21) != 0)) {
      setState(805);
      antlrcpp::downCast<ForClauseContext*>(_localctx)->postStmt = simpleStmt();
    }

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::WhileStmtContext::WhileStmtContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::WhileStmtContext::While() {
  return getToken(AutoTenV1Parser::While, 0);
}

tree::TerminalNode* AutoTenV1Parser::WhileStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::WhileStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::WhileStmtContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::WhileStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

size_t AutoTenV1Parser::WhileStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleWhileStmt;
}

void AutoTenV1Parser::WhileStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterWhileStmt(this);
}

void AutoTenV1Parser::WhileStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitWhileStmt(this);
}

std::any AutoTenV1Parser::WhileStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitWhileStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::WhileStmtContext* AutoTenV1Parser::whileStmt() {
  WhileStmtContext* _localctx = _tracker.createInstance<WhileStmtContext>(_ctx, getState());
  enterRule(_localctx, 160, AutoTenV1Parser::RuleWhileStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    match(AutoTenV1Parser::While);
    setState(809);
    match(AutoTenV1Parser::LeftParen);

    setState(810);
    expression(0);
    setState(811);
    match(AutoTenV1Parser::RightParen);
    setState(812);
    block();

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoWhileStmtContext
//------------------------------------------------------------------

AutoTenV1Parser::DoWhileStmtContext::DoWhileStmtContext(ParserRuleContext* parent,
                                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::DoWhileStmtContext::Do() {
  return getToken(AutoTenV1Parser::Do, 0);
}

AutoTenV1Parser::BlockContext* AutoTenV1Parser::DoWhileStmtContext::block() {
  return getRuleContext<AutoTenV1Parser::BlockContext>(0);
}

tree::TerminalNode* AutoTenV1Parser::DoWhileStmtContext::While() {
  return getToken(AutoTenV1Parser::While, 0);
}

tree::TerminalNode* AutoTenV1Parser::DoWhileStmtContext::LeftParen() {
  return getToken(AutoTenV1Parser::LeftParen, 0);
}

tree::TerminalNode* AutoTenV1Parser::DoWhileStmtContext::RightParen() {
  return getToken(AutoTenV1Parser::RightParen, 0);
}

AutoTenV1Parser::ExpressionContext* AutoTenV1Parser::DoWhileStmtContext::expression() {
  return getRuleContext<AutoTenV1Parser::ExpressionContext>(0);
}

size_t AutoTenV1Parser::DoWhileStmtContext::getRuleIndex() const {
  return AutoTenV1Parser::RuleDoWhileStmt;
}

void AutoTenV1Parser::DoWhileStmtContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterDoWhileStmt(this);
}

void AutoTenV1Parser::DoWhileStmtContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitDoWhileStmt(this);
}

std::any AutoTenV1Parser::DoWhileStmtContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitDoWhileStmt(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::DoWhileStmtContext* AutoTenV1Parser::doWhileStmt() {
  DoWhileStmtContext* _localctx = _tracker.createInstance<DoWhileStmtContext>(_ctx, getState());
  enterRule(_localctx, 162, AutoTenV1Parser::RuleDoWhileStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(814);
    match(AutoTenV1Parser::Do);
    setState(815);
    block();
    setState(816);
    match(AutoTenV1Parser::While);
    setState(817);
    match(AutoTenV1Parser::LeftParen);

    setState(818);
    expression(0);
    setState(819);
    match(AutoTenV1Parser::RightParen);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EosContext ------------------------------------------------------------------

AutoTenV1Parser::EosContext::EosContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode* AutoTenV1Parser::EosContext::Semi() {
  return getToken(AutoTenV1Parser::Semi, 0);
}

size_t AutoTenV1Parser::EosContext::getRuleIndex() const { return AutoTenV1Parser::RuleEos; }

void AutoTenV1Parser::EosContext::enterRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->enterEos(this);
}

void AutoTenV1Parser::EosContext::exitRule(tree::ParseTreeListener* listener) {
  auto parserListener = dynamic_cast<AutoTenV1ParserListener*>(listener);
  if (parserListener != nullptr) parserListener->exitEos(this);
}

std::any AutoTenV1Parser::EosContext::accept(tree::ParseTreeVisitor* visitor) {
  if (auto parserVisitor = dynamic_cast<AutoTenV1ParserVisitor*>(visitor))
    return parserVisitor->visitEos(this);
  else
    return visitor->visitChildren(this);
}

AutoTenV1Parser::EosContext* AutoTenV1Parser::eos() {
  EosContext* _localctx = _tracker.createInstance<EosContext>(_ctx, getState());
  enterRule(_localctx, 164, AutoTenV1Parser::RuleEos);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(821);
    match(AutoTenV1Parser::Semi);

  } catch (RecognitionException& e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool AutoTenV1Parser::sempred(RuleContext* context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 29:
      return expressionSempred(antlrcpp::downCast<ExpressionContext*>(context), predicateIndex);
    case 30:
      return primaryExprSempred(antlrcpp::downCast<PrimaryExprContext*>(context), predicateIndex);

    default: break;
  }
  return true;
}

bool AutoTenV1Parser::expressionSempred(ExpressionContext* _localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 5);
    case 1: return precpred(_ctx, 4);
    case 2: return precpred(_ctx, 3);
    case 3: return precpred(_ctx, 2);
    case 4: return precpred(_ctx, 1);

    default: break;
  }
  return true;
}

bool AutoTenV1Parser::primaryExprSempred(PrimaryExprContext* _localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 5: return precpred(_ctx, 1);

    default: break;
  }
  return true;
}

void AutoTenV1Parser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  autotenv1parserParserInitialize();
#else
  ::antlr4::internal::call_once(autotenv1parserParserOnceFlag, autotenv1parserParserInitialize);
#endif
}
